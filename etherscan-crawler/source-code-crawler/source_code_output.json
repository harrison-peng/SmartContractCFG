[
  {},
  {
    "address": "0x285761a0fd6aefbee84f7377db9f3b666f04d41d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2b377a3e81752f4720287a38fb10a29878076c19",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdb1c54df945050cefac0fab75d3c955f50c1bcba",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x40acc9b5422ef13da74600821b227c21718c45e8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6d7cb90df1f291cea7f34690521c18c9ee0fdbae",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc6acb83b70088a3ca22bc908b780e9669c891609",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa6cc83cab18fbdf21310463d37e0dd2e8d3e3f60",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5cbf82cdc7873f8ab76f9815742c3c20a10d6504",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa328b82823d06a3ede2e063a6b954b68cba9d9ff",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x066a073e3c25d6764039ce44e4a8a4672a4562fe",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcae39f1d5ebadfe850213d18cc81137fa14f1df1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd15db309702c4468a877e9775f634e014ab48856",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x31c26225d2395acdcd5264d12499958ad0c5493f",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.6;\r\n\r\ncontract DXF_Tokens{\r\n\r\n  //States\r\n  bool public dxfOpen=true;\r\n  bool public refundState;\r\n  bool public transferLocked=true;\r\n\r\n  uint256 public startingDateFunding;\r\n  uint256 public closingDateFunding;\r\n  //Maximum number of participants\r\n  uint256 public constant maxNumberMembers=5000;\r\n  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\r\n  uint256 public totalTokens;\r\n  uint256 public constant tokensCreationMin = 25000 ether;\r\n  uint256 public constant tokensCreationCap = 75000 ether;\r\n  //Cap of 12500 ethers worth of tokens to be distributed \r\n  //to previous DO members in exchange for their rouleth accounts\r\n  uint256 public remainingTokensVIPs=12500 ether;\r\n  uint256 public constant tokensCreationVIPsCap = 12500 ether; \r\n\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => bool) vips;\r\n  mapping (address => uint256) indexMembers;\r\n  \r\n  struct Member\r\n  {\r\n    address member;\r\n    uint timestamp;\r\n    uint initial_value;\r\n  }\r\n  Member[] public members;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event failingRefund(address indexed _to, uint256 _value);\r\n  event VipMigration(address indexed _vip, uint256 _value);\r\n  event newMember(address indexed _from);\r\n\r\n  // Token parameters\r\n  string public constant name = \"DXF - Decentralized eXperience Friends\";\r\n  string public constant symbol = \"DXF\";\r\n  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n  address public admin;\r\n  address public multisigDXF;\r\n\r\n  modifier onlyAdmin()\r\n  {\r\n    if (msg.sender!=admin) throw;\r\n    _;\r\n  }\r\n\r\n  function DXF_Tokens()\r\n  {\r\n    admin = msg.sender;\r\n    startingDateFunding=now;\r\n    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\r\n    //increment array by 1 for indexes\r\n    members.push(Member(0,0,0));\r\n  }\r\n\r\n\r\n  //empty fallback\r\n  function ()\r\n    {\r\n      throw;\r\n    }\r\n\r\n  //USER FUNCTIONS  \r\n  /// @notice Create tokens when funding is active.\r\n  /// @notice By using this function you accept the terms of DXF\r\n  /// @dev Required state: Funding Active\r\n  /// @dev State transition: -> Funding Success (only if cap reached)\r\n  function acceptTermsAndJoinDXF() payable external \r\n  {\r\n    // refuse if more than 12 months have passed\r\n    if (now>startingDateFunding+365 days) throw;\r\n    // Abort if DXF is not open.\r\n    if (!dxfOpen) throw;\r\n    // verify if the account is not a VIP account\r\n    if (vips[msg.sender]) throw;\r\n    // Do not allow creating less than 10 ether or more than the cap tokens.\r\n    if (msg.value < 10 ether) throw;\r\n    if (msg.value > (tokensCreationCap - totalTokens)) throw;\r\n    // Enforce cap of 10 000 ethers per address / individual\r\n    if (msg.value > (10000 ether - balances[msg.sender])) throw;\r\n    // Register member\r\n    if (balances[msg.sender]==0)\r\n      {\r\n        newMember(msg.sender); //event\r\n\tindexMembers[msg.sender]=members.length;\r\n\tmembers.push(Member(msg.sender,now,msg.value));\r\n      }\r\n    else\r\n      {\r\n\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\r\n      }\r\n    if (members.length>maxNumberMembers) throw;\r\n    //Send the funds to the MultiSig Wallet\r\n    if (multisigDXF==0) throw;\r\n    if (!multisigDXF.send(msg.value)) throw;\r\n    // Assign new tokens to the sender\r\n    uint numTokens = msg.value;\r\n    totalTokens += numTokens;\r\n    // Do not allow creating tokens if we don't leave enough for the VIPs\r\n    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\r\n    balances[msg.sender] += numTokens;\r\n    // Log token creation event\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n\r\n\r\n  //NOT INCLUDED IN LATEST VERSION\r\n  //since we move the funds to multisig\r\n  //refund will be with payback()\r\n  /* /// @notice Get back the ether sent during the funding in case the funding */\r\n  /* /// has not reached the minimum level. */\r\n  /* /// @dev Required state: refund true */\r\n  /* function refund() */\r\n  /* { */\r\n  /*   // Abort if not in refund state */\r\n  /*   if (!refundState) throw; */\r\n  /*   // Not refunded for VIP, we will do a manual refund for them */\r\n  /*   // via the payback function */\r\n  /*   if (vips[msg.sender]) throw; */\r\n  /*   uint value = balances[msg.sender]; */\r\n  /*   if (value == 0) throw; */\r\n  /*   balances[msg.sender] = 0; */\r\n  /*   totalTokens -= value; */\r\n  /*   delete members[indexMembers[msg.sender]]; */\r\n  /*   indexMembers[msg.sender]=0; */\r\n  /*   Refund(msg.sender, value); */\r\n  /*   if (!msg.sender.send(value)) throw; */\r\n  /* } */\r\n\r\n\r\n  //@notice Full Tranfer of DX tokens from sender to '_to'\r\n  //@dev only active if tranfer has been unlocked\r\n  //@param _to address of recipient\r\n  //@param _value amount to tranfer\r\n  //@return success of tranfer ?\r\n  function fullTransfer(address _to) returns (bool)\r\n  {\r\n    // Cancel if tranfer is not allowed\r\n    if (transferLocked) throw;\r\n    if (balances[_to]!=0) throw;\r\n    if (balances[msg.sender]!=0)\r\n      {\r\n\tuint senderBalance = balances[msg.sender];\r\n\tbalances[msg.sender] = 0;\r\n\tbalances[_to]=senderBalance;\r\n\tif (vips[msg.sender])\r\n\t  {\r\n\t    vips[_to]=true;\r\n\t    vips[msg.sender]=false;\r\n\t  }\r\n\tmembers[indexMembers[msg.sender]].member=_to;\r\n\tindexMembers[_to]=indexMembers[msg.sender];\r\n\tindexMembers[msg.sender]=0;\r\n\tTransfer(msg.sender, _to, senderBalance);\r\n\treturn true;\r\n      }\r\n    else\r\n      {\r\n\treturn false;\r\n      }\r\n  }\r\n\r\n\r\n  //ADMIN FUNCTIONS\r\n\r\n\r\n  //@notice called by Admin to manually register migration of previous DO\r\n  //@dev can not be called with a _vip address that is already investor\r\n  //@dev can be called even after the DO is sealed\r\n  //@param _value : balance of VIP at DXDO's creation date\r\n  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\r\n    onlyAdmin\r\n  {\r\n    if (_vip==0) throw;\r\n    if (_vip!=_vip_confirm) throw;\r\n    //don't allow migration to a non empty address\r\n    if (balances[_vip]!=0) throw; \r\n    if (_previous_balance==0) throw;\r\n    uint numberTokens=_previous_balance+(_previous_balance/3);\r\n    totalTokens+=numberTokens;\r\n    //too many tokens created via VIP migration\r\n    if (numberTokens>remainingTokensVIPs) throw;     \r\n    remainingTokensVIPs-=numberTokens;\r\n    balances[_vip]+=numberTokens;\r\n    indexMembers[_vip]=members.length;\r\n    members.push(Member(_vip,now,_previous_balance));\r\n    vips[_vip]=true;\r\n    VipMigration(_vip,_previous_balance);\r\n  }\r\n\r\n\r\n  /// @notice Pay back the ether contributed to the DAO\r\n  function paybackContribution(uint i)\r\n    payable\r\n    onlyAdmin\r\n  {\r\n    address memberRefunded=members[i].member;\r\n    if (memberRefunded==0) throw;\r\n    uint amountTokens=msg.value;\r\n    if (vips[memberRefunded]) \r\n      {\r\n\tamountTokens+=amountTokens/3;\r\n\tremainingTokensVIPs+=amountTokens;\r\n      }\r\n    if (amountTokens>balances[memberRefunded]) throw;\r\n    balances[memberRefunded]-=amountTokens;\r\n    totalTokens-=amountTokens;\r\n    if (balances[memberRefunded]==0) \r\n      {\r\n\tdelete members[i];\r\n\tvips[memberRefunded]=false;\r\n\tindexMembers[memberRefunded]=0;\r\n      }\r\n    if (!memberRefunded.send(msg.value))\r\n      {\r\n        failingRefund(memberRefunded,msg.value);\r\n      }\r\n    Refund(memberRefunded,msg.value);\r\n  }\r\n\r\n\r\n  function changeAdmin(address _admin, address _admin_confirm)\r\n    onlyAdmin\r\n  {\r\n    if (_admin!=_admin_confirm) throw;\r\n    if (_admin==0) throw;\r\n    admin=_admin;\r\n  }\r\n\r\n  //@notice called to seal the DO\r\n  //@dev can not be opened again, marks the end of the fundraising \r\n  //and the recruitment in the DO\r\n  function closeFunding()\r\n    onlyAdmin\r\n  {\r\n    closingDateFunding=now;\r\n    dxfOpen=false;\r\n    //verify if the cap has been reached\r\n    //if not : refund mode\r\n    if (totalTokens<tokensCreationMin)\r\n      {\r\n\trefundState=true;\r\n      }\r\n    else\r\n      {\r\n        //send balance, but should not be necessary.      \r\n\tif(!admin.send(this.balance)) throw;\r\n      }\r\n  }\r\n\r\n  //NOT INCLUDED\r\n  /* function reopenDO() */\r\n  /*   onlyAdmin */\r\n  /* { */\r\n  /*   dxfOpen=true; */\r\n  /*   transferLocked=true; */\r\n  /* } */\r\n\r\n  function allowTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=false;\r\n  }\r\n\r\n  function disableTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=true;\r\n  }\r\n\r\n\r\n  //Constant Functions\r\n  function totalSupply() external constant returns (uint256) \r\n  {\r\n    return totalTokens;\r\n  }\r\n\r\n  function balanceOf(address _owner) external constant returns (uint256) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \r\n  {\r\n    vip=vips[_owner];\r\n    balance_dxf=balances[_owner]/(1 ether);\r\n    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\r\n  }\r\n\r\n\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"refundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accountInformation\",\"outputs\":[{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"balance_dxf\",\"type\":\"uint256\"},{\"name\":\"share_dxf_per_thousands\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_admin_confirm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fullTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationVIPsCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"paybackContribution\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vip\",\"type\":\"address\"},{\"name\":\"_vip_confirm\",\"type\":\"address\"},{\"name\":\"_previous_balance\",\"type\":\"uint256\"}],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"initial_value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dxfOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigDXF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTermsAndJoinDXF\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensVIPs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"failingRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vip\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"VipMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"newMember\",\"type\":\"event\"}]",
        "ContractName": "DXF_Tokens",
        "CompilerVersion": "v0.4.6+commit.2dabbdf0",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7efd3a0149fd4174bb8b08065001e5f7c3a00968",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.6;\r\n\r\ncontract DXF_Tokens{\r\n\r\n  //States\r\n  bool public dxfOpen=true;\r\n  bool public refundState;\r\n  bool public transferLocked=true;\r\n\r\n  uint256 public startingDateFunding;\r\n  uint256 public closingDateFunding;\r\n  //Maximum number of participants\r\n  uint256 public constant maxNumberMembers=5000;\r\n  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\r\n  uint256 public totalTokens;\r\n  uint256 public constant tokensCreationMin = 25000 ether;\r\n  uint256 public constant tokensCreationCap = 75000 ether;\r\n  //Cap of 12500 ethers worth of tokens to be distributed \r\n  //to previous DO members in exchange for their rouleth accounts\r\n  uint256 public remainingTokensVIPs=12500 ether;\r\n  uint256 public constant tokensCreationVIPsCap = 12500 ether; \r\n\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => bool) vips;\r\n  mapping (address => uint256) indexMembers;\r\n  \r\n  struct Member\r\n  {\r\n    address member;\r\n    uint timestamp;\r\n    uint initial_value;\r\n  }\r\n  Member[] public members;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event failingRefund(address indexed _to, uint256 _value);\r\n  event VipMigration(address indexed _vip, uint256 _value);\r\n  event newMember(address indexed _from);\r\n\r\n  // Token parameters\r\n  string public constant name = \"DXF - Decentralized eXperience Friends\";\r\n  string public constant symbol = \"DXF\";\r\n  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n  address public admin;\r\n  address public multisigDXF;\r\n\r\n  modifier onlyAdmin()\r\n  {\r\n    if (msg.sender!=admin) throw;\r\n    _;\r\n  }\r\n\r\n  function DXF_Tokens()\r\n  {\r\n    admin = msg.sender;\r\n    startingDateFunding=now;\r\n    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\r\n    //increment array by 1 for indexes\r\n    members.push(Member(0,0,0));\r\n  }\r\n\r\n\r\n  //empty fallback\r\n  function ()\r\n    {\r\n      throw;\r\n    }\r\n\r\n  //USER FUNCTIONS  \r\n  /// @notice Create tokens when funding is active.\r\n  /// @notice By using this function you accept the terms of DXF\r\n  /// @dev Required state: Funding Active\r\n  /// @dev State transition: -> Funding Success (only if cap reached)\r\n  function acceptTermsAndJoinDXF() payable external \r\n  {\r\n    // refuse if more than 12 months have passed\r\n    if (now>startingDateFunding+365 days) throw;\r\n    // Abort if DXF is not open.\r\n    if (!dxfOpen) throw;\r\n    // verify if the account is not a VIP account\r\n    if (vips[msg.sender]) throw;\r\n    // Do not allow creating less than 10 ether or more than the cap tokens.\r\n    if (msg.value < 10 ether) throw;\r\n    if (msg.value > (tokensCreationCap - totalTokens)) throw;\r\n    // Enforce cap of 10 000 ethers per address / individual\r\n    if (msg.value > (10000 ether - balances[msg.sender])) throw;\r\n    // Register member\r\n    if (balances[msg.sender]==0)\r\n      {\r\n        newMember(msg.sender); //event\r\n\tindexMembers[msg.sender]=members.length;\r\n\tmembers.push(Member(msg.sender,now,msg.value));\r\n      }\r\n    else\r\n      {\r\n\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\r\n      }\r\n    if (members.length>maxNumberMembers) throw;\r\n    //Send the funds to the MultiSig Wallet\r\n    if (multisigDXF==0) throw;\r\n    if (!multisigDXF.send(msg.value)) throw;\r\n    // Assign new tokens to the sender\r\n    uint numTokens = msg.value;\r\n    totalTokens += numTokens;\r\n    // Do not allow creating tokens if we don't leave enough for the VIPs\r\n    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\r\n    balances[msg.sender] += numTokens;\r\n    // Log token creation event\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n\r\n\r\n  //NOT INCLUDED IN LATEST VERSION\r\n  //since we move the funds to multisig\r\n  //refund will be with payback()\r\n  /* /// @notice Get back the ether sent during the funding in case the funding */\r\n  /* /// has not reached the minimum level. */\r\n  /* /// @dev Required state: refund true */\r\n  /* function refund() */\r\n  /* { */\r\n  /*   // Abort if not in refund state */\r\n  /*   if (!refundState) throw; */\r\n  /*   // Not refunded for VIP, we will do a manual refund for them */\r\n  /*   // via the payback function */\r\n  /*   if (vips[msg.sender]) throw; */\r\n  /*   uint value = balances[msg.sender]; */\r\n  /*   if (value == 0) throw; */\r\n  /*   balances[msg.sender] = 0; */\r\n  /*   totalTokens -= value; */\r\n  /*   delete members[indexMembers[msg.sender]]; */\r\n  /*   indexMembers[msg.sender]=0; */\r\n  /*   Refund(msg.sender, value); */\r\n  /*   if (!msg.sender.send(value)) throw; */\r\n  /* } */\r\n\r\n\r\n  //@notice Full Tranfer of DX tokens from sender to '_to'\r\n  //@dev only active if tranfer has been unlocked\r\n  //@param _to address of recipient\r\n  //@param _value amount to tranfer\r\n  //@return success of tranfer ?\r\n  function fullTransfer(address _to) returns (bool)\r\n  {\r\n    // Cancel if tranfer is not allowed\r\n    if (transferLocked) throw;\r\n    if (balances[_to]!=0) throw;\r\n    if (balances[msg.sender]!=0)\r\n      {\r\n\tuint senderBalance = balances[msg.sender];\r\n\tbalances[msg.sender] = 0;\r\n\tbalances[_to]=senderBalance;\r\n\tif (vips[msg.sender])\r\n\t  {\r\n\t    vips[_to]=true;\r\n\t    vips[msg.sender]=false;\r\n\t  }\r\n\tmembers[indexMembers[msg.sender]].member=_to;\r\n\tindexMembers[_to]=indexMembers[msg.sender];\r\n\tindexMembers[msg.sender]=0;\r\n\tTransfer(msg.sender, _to, senderBalance);\r\n\treturn true;\r\n      }\r\n    else\r\n      {\r\n\treturn false;\r\n      }\r\n  }\r\n\r\n\r\n  //ADMIN FUNCTIONS\r\n\r\n\r\n  //@notice called by Admin to manually register migration of previous DO\r\n  //@dev can not be called with a _vip address that is already investor\r\n  //@dev can be called even after the DO is sealed\r\n  //@param _value : balance of VIP at DXDO's creation date\r\n  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\r\n    onlyAdmin\r\n  {\r\n    if (_vip==0) throw;\r\n    if (_vip!=_vip_confirm) throw;\r\n    //don't allow migration to a non empty address\r\n    if (balances[_vip]!=0) throw; \r\n    if (_previous_balance==0) throw;\r\n    uint numberTokens=_previous_balance+(_previous_balance/3);\r\n    totalTokens+=numberTokens;\r\n    //too many tokens created via VIP migration\r\n    if (numberTokens>remainingTokensVIPs) throw;     \r\n    remainingTokensVIPs-=numberTokens;\r\n    balances[_vip]+=numberTokens;\r\n    indexMembers[_vip]=members.length;\r\n    members.push(Member(_vip,now,_previous_balance));\r\n    vips[_vip]=true;\r\n    VipMigration(_vip,_previous_balance);\r\n  }\r\n\r\n\r\n  /// @notice Pay back the ether contributed to the DAO\r\n  function paybackContribution(uint i)\r\n    payable\r\n    onlyAdmin\r\n  {\r\n    address memberRefunded=members[i].member;\r\n    if (memberRefunded==0) throw;\r\n    uint amountTokens=msg.value;\r\n    if (vips[memberRefunded]) \r\n      {\r\n\tamountTokens+=amountTokens/3;\r\n\tremainingTokensVIPs+=amountTokens;\r\n      }\r\n    if (amountTokens>balances[memberRefunded]) throw;\r\n    balances[memberRefunded]-=amountTokens;\r\n    totalTokens-=amountTokens;\r\n    if (balances[memberRefunded]==0) \r\n      {\r\n\tdelete members[i];\r\n\tvips[memberRefunded]=false;\r\n\tindexMembers[memberRefunded]=0;\r\n      }\r\n    if (!memberRefunded.send(msg.value))\r\n      {\r\n        failingRefund(memberRefunded,msg.value);\r\n      }\r\n    Refund(memberRefunded,msg.value);\r\n  }\r\n\r\n\r\n  function changeAdmin(address _admin, address _admin_confirm)\r\n    onlyAdmin\r\n  {\r\n    if (_admin!=_admin_confirm) throw;\r\n    if (_admin==0) throw;\r\n    admin=_admin;\r\n  }\r\n\r\n  //@notice called to seal the DO\r\n  //@dev can not be opened again, marks the end of the fundraising \r\n  //and the recruitment in the DO\r\n  function closeFunding()\r\n    onlyAdmin\r\n  {\r\n    closingDateFunding=now;\r\n    dxfOpen=false;\r\n    //verify if the cap has been reached\r\n    //if not : refund mode\r\n    if (totalTokens<tokensCreationMin)\r\n      {\r\n\trefundState=true;\r\n      }\r\n    else\r\n      {\r\n        //send balance, but should not be necessary.      \r\n\tif(!admin.send(this.balance)) throw;\r\n      }\r\n  }\r\n\r\n  //NOT INCLUDED\r\n  /* function reopenDO() */\r\n  /*   onlyAdmin */\r\n  /* { */\r\n  /*   dxfOpen=true; */\r\n  /*   transferLocked=true; */\r\n  /* } */\r\n\r\n  function allowTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=false;\r\n  }\r\n\r\n  function disableTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=true;\r\n  }\r\n\r\n\r\n  //Constant Functions\r\n  function totalSupply() external constant returns (uint256) \r\n  {\r\n    return totalTokens;\r\n  }\r\n\r\n  function balanceOf(address _owner) external constant returns (uint256) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \r\n  {\r\n    vip=vips[_owner];\r\n    balance_dxf=balances[_owner]/(1 ether);\r\n    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\r\n  }\r\n\r\n\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"refundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accountInformation\",\"outputs\":[{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"balance_dxf\",\"type\":\"uint256\"},{\"name\":\"share_dxf_per_thousands\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_admin_confirm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fullTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationVIPsCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"paybackContribution\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vip\",\"type\":\"address\"},{\"name\":\"_vip_confirm\",\"type\":\"address\"},{\"name\":\"_previous_balance\",\"type\":\"uint256\"}],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"initial_value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dxfOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigDXF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTermsAndJoinDXF\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensVIPs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"failingRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vip\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"VipMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"newMember\",\"type\":\"event\"}]",
        "ContractName": "DXF_Tokens",
        "CompilerVersion": "v0.4.6+commit.2dabbdf0",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1bb3ac952015995140031d42fcf7b649047afc27",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.6;\r\n\r\ncontract DXF_Tokens{\r\n\r\n  //States\r\n  bool public dxfOpen=true;\r\n  bool public refundState;\r\n  bool public transferLocked=true;\r\n\r\n  uint256 public startingDateFunding;\r\n  uint256 public closingDateFunding;\r\n  //Maximum number of participants\r\n  uint256 public constant maxNumberMembers=5000;\r\n  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\r\n  uint256 public totalTokens;\r\n  uint256 public constant tokensCreationMin = 25000 ether;\r\n  uint256 public constant tokensCreationCap = 75000 ether;\r\n  //Cap of 12500 ethers worth of tokens to be distributed \r\n  //to previous DO members in exchange for their rouleth accounts\r\n  uint256 public remainingTokensVIPs=12500 ether;\r\n  uint256 public constant tokensCreationVIPsCap = 12500 ether; \r\n\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => bool) vips;\r\n  mapping (address => uint256) indexMembers;\r\n  \r\n  struct Member\r\n  {\r\n    address member;\r\n    uint timestamp;\r\n    uint initial_value;\r\n  }\r\n  Member[] public members;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event failingRefund(address indexed _to, uint256 _value);\r\n  event VipMigration(address indexed _vip, uint256 _value);\r\n  event newMember(address indexed _from);\r\n\r\n  // Token parameters\r\n  string public constant name = \"DXF - Decentralized eXperience Friends\";\r\n  string public constant symbol = \"DXF\";\r\n  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n  address public admin;\r\n  address public multisigDXF;\r\n\r\n  modifier onlyAdmin()\r\n  {\r\n    if (msg.sender!=admin) throw;\r\n    _;\r\n  }\r\n\r\n  function DXF_Tokens()\r\n  {\r\n    admin = msg.sender;\r\n    startingDateFunding=now;\r\n    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\r\n    //increment array by 1 for indexes\r\n    members.push(Member(0,0,0));\r\n  }\r\n\r\n\r\n  //empty fallback\r\n  function ()\r\n    {\r\n      throw;\r\n    }\r\n\r\n  //USER FUNCTIONS  \r\n  /// @notice Create tokens when funding is active.\r\n  /// @notice By using this function you accept the terms of DXF\r\n  /// @dev Required state: Funding Active\r\n  /// @dev State transition: -> Funding Success (only if cap reached)\r\n  function acceptTermsAndJoinDXF() payable external \r\n  {\r\n    // refuse if more than 12 months have passed\r\n    if (now>startingDateFunding+365 days) throw;\r\n    // Abort if DXF is not open.\r\n    if (!dxfOpen) throw;\r\n    // verify if the account is not a VIP account\r\n    if (vips[msg.sender]) throw;\r\n    // Do not allow creating less than 10 ether or more than the cap tokens.\r\n    if (msg.value < 10 ether) throw;\r\n    if (msg.value > (tokensCreationCap - totalTokens)) throw;\r\n    // Enforce cap of 10 000 ethers per address / individual\r\n    if (msg.value > (10000 ether - balances[msg.sender])) throw;\r\n    // Register member\r\n    if (balances[msg.sender]==0)\r\n      {\r\n        newMember(msg.sender); //event\r\n\tindexMembers[msg.sender]=members.length;\r\n\tmembers.push(Member(msg.sender,now,msg.value));\r\n      }\r\n    else\r\n      {\r\n\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\r\n      }\r\n    if (members.length>maxNumberMembers) throw;\r\n    //Send the funds to the MultiSig Wallet\r\n    if (multisigDXF==0) throw;\r\n    if (!multisigDXF.send(msg.value)) throw;\r\n    // Assign new tokens to the sender\r\n    uint numTokens = msg.value;\r\n    totalTokens += numTokens;\r\n    // Do not allow creating tokens if we don't leave enough for the VIPs\r\n    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\r\n    balances[msg.sender] += numTokens;\r\n    // Log token creation event\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n\r\n\r\n  //NOT INCLUDED IN LATEST VERSION\r\n  //since we move the funds to multisig\r\n  //refund will be with payback()\r\n  /* /// @notice Get back the ether sent during the funding in case the funding */\r\n  /* /// has not reached the minimum level. */\r\n  /* /// @dev Required state: refund true */\r\n  /* function refund() */\r\n  /* { */\r\n  /*   // Abort if not in refund state */\r\n  /*   if (!refundState) throw; */\r\n  /*   // Not refunded for VIP, we will do a manual refund for them */\r\n  /*   // via the payback function */\r\n  /*   if (vips[msg.sender]) throw; */\r\n  /*   uint value = balances[msg.sender]; */\r\n  /*   if (value == 0) throw; */\r\n  /*   balances[msg.sender] = 0; */\r\n  /*   totalTokens -= value; */\r\n  /*   delete members[indexMembers[msg.sender]]; */\r\n  /*   indexMembers[msg.sender]=0; */\r\n  /*   Refund(msg.sender, value); */\r\n  /*   if (!msg.sender.send(value)) throw; */\r\n  /* } */\r\n\r\n\r\n  //@notice Full Tranfer of DX tokens from sender to '_to'\r\n  //@dev only active if tranfer has been unlocked\r\n  //@param _to address of recipient\r\n  //@param _value amount to tranfer\r\n  //@return success of tranfer ?\r\n  function fullTransfer(address _to) returns (bool)\r\n  {\r\n    // Cancel if tranfer is not allowed\r\n    if (transferLocked) throw;\r\n    if (balances[_to]!=0) throw;\r\n    if (balances[msg.sender]!=0)\r\n      {\r\n\tuint senderBalance = balances[msg.sender];\r\n\tbalances[msg.sender] = 0;\r\n\tbalances[_to]=senderBalance;\r\n\tif (vips[msg.sender])\r\n\t  {\r\n\t    vips[_to]=true;\r\n\t    vips[msg.sender]=false;\r\n\t  }\r\n\tmembers[indexMembers[msg.sender]].member=_to;\r\n\tindexMembers[_to]=indexMembers[msg.sender];\r\n\tindexMembers[msg.sender]=0;\r\n\tTransfer(msg.sender, _to, senderBalance);\r\n\treturn true;\r\n      }\r\n    else\r\n      {\r\n\treturn false;\r\n      }\r\n  }\r\n\r\n\r\n  //ADMIN FUNCTIONS\r\n\r\n\r\n  //@notice called by Admin to manually register migration of previous DO\r\n  //@dev can not be called with a _vip address that is already investor\r\n  //@dev can be called even after the DO is sealed\r\n  //@param _value : balance of VIP at DXDO's creation date\r\n  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\r\n    onlyAdmin\r\n  {\r\n    if (_vip==0) throw;\r\n    if (_vip!=_vip_confirm) throw;\r\n    //don't allow migration to a non empty address\r\n    if (balances[_vip]!=0) throw; \r\n    if (_previous_balance==0) throw;\r\n    uint numberTokens=_previous_balance+(_previous_balance/3);\r\n    totalTokens+=numberTokens;\r\n    //too many tokens created via VIP migration\r\n    if (numberTokens>remainingTokensVIPs) throw;     \r\n    remainingTokensVIPs-=numberTokens;\r\n    balances[_vip]+=numberTokens;\r\n    indexMembers[_vip]=members.length;\r\n    members.push(Member(_vip,now,_previous_balance));\r\n    vips[_vip]=true;\r\n    VipMigration(_vip,_previous_balance);\r\n  }\r\n\r\n\r\n  /// @notice Pay back the ether contributed to the DAO\r\n  function paybackContribution(uint i)\r\n    payable\r\n    onlyAdmin\r\n  {\r\n    address memberRefunded=members[i].member;\r\n    if (memberRefunded==0) throw;\r\n    uint amountTokens=msg.value;\r\n    if (vips[memberRefunded]) \r\n      {\r\n\tamountTokens+=amountTokens/3;\r\n\tremainingTokensVIPs+=amountTokens;\r\n      }\r\n    if (amountTokens>balances[memberRefunded]) throw;\r\n    balances[memberRefunded]-=amountTokens;\r\n    totalTokens-=amountTokens;\r\n    if (balances[memberRefunded]==0) \r\n      {\r\n\tdelete members[i];\r\n\tvips[memberRefunded]=false;\r\n\tindexMembers[memberRefunded]=0;\r\n      }\r\n    if (!memberRefunded.send(msg.value))\r\n      {\r\n        failingRefund(memberRefunded,msg.value);\r\n      }\r\n    Refund(memberRefunded,msg.value);\r\n  }\r\n\r\n\r\n  function changeAdmin(address _admin, address _admin_confirm)\r\n    onlyAdmin\r\n  {\r\n    if (_admin!=_admin_confirm) throw;\r\n    if (_admin==0) throw;\r\n    admin=_admin;\r\n  }\r\n\r\n  //@notice called to seal the DO\r\n  //@dev can not be opened again, marks the end of the fundraising \r\n  //and the recruitment in the DO\r\n  function closeFunding()\r\n    onlyAdmin\r\n  {\r\n    closingDateFunding=now;\r\n    dxfOpen=false;\r\n    //verify if the cap has been reached\r\n    //if not : refund mode\r\n    if (totalTokens<tokensCreationMin)\r\n      {\r\n\trefundState=true;\r\n      }\r\n    else\r\n      {\r\n        //send balance, but should not be necessary.      \r\n\tif(!admin.send(this.balance)) throw;\r\n      }\r\n  }\r\n\r\n  //NOT INCLUDED\r\n  /* function reopenDO() */\r\n  /*   onlyAdmin */\r\n  /* { */\r\n  /*   dxfOpen=true; */\r\n  /*   transferLocked=true; */\r\n  /* } */\r\n\r\n  function allowTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=false;\r\n  }\r\n\r\n  function disableTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=true;\r\n  }\r\n\r\n\r\n  //Constant Functions\r\n  function totalSupply() external constant returns (uint256) \r\n  {\r\n    return totalTokens;\r\n  }\r\n\r\n  function balanceOf(address _owner) external constant returns (uint256) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \r\n  {\r\n    vip=vips[_owner];\r\n    balance_dxf=balances[_owner]/(1 ether);\r\n    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\r\n  }\r\n\r\n\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"refundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accountInformation\",\"outputs\":[{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"balance_dxf\",\"type\":\"uint256\"},{\"name\":\"share_dxf_per_thousands\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_admin_confirm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fullTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationVIPsCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"paybackContribution\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vip\",\"type\":\"address\"},{\"name\":\"_vip_confirm\",\"type\":\"address\"},{\"name\":\"_previous_balance\",\"type\":\"uint256\"}],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"initial_value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dxfOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigDXF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTermsAndJoinDXF\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensVIPs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"failingRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vip\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"VipMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"newMember\",\"type\":\"event\"}]",
        "ContractName": "DXF_Tokens",
        "CompilerVersion": "v0.4.6+commit.2dabbdf0",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x49f988d49f6cbfb3a24cc22b468109dcd0695429",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.6;\r\n\r\ncontract DXF_Tokens{\r\n\r\n  //States\r\n  bool public dxfOpen=true;\r\n  bool public refundState;\r\n  bool public transferLocked=true;\r\n\r\n  uint256 public startingDateFunding;\r\n  uint256 public closingDateFunding;\r\n  //Maximum number of participants\r\n  uint256 public constant maxNumberMembers=5000;\r\n  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\r\n  uint256 public totalTokens;\r\n  uint256 public constant tokensCreationMin = 25000 ether;\r\n  uint256 public constant tokensCreationCap = 75000 ether;\r\n  //Cap of 12500 ethers worth of tokens to be distributed \r\n  //to previous DO members in exchange for their rouleth accounts\r\n  uint256 public remainingTokensVIPs=12500 ether;\r\n  uint256 public constant tokensCreationVIPsCap = 12500 ether; \r\n\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => bool) vips;\r\n  mapping (address => uint256) indexMembers;\r\n  \r\n  struct Member\r\n  {\r\n    address member;\r\n    uint timestamp;\r\n    uint initial_value;\r\n  }\r\n  Member[] public members;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event failingRefund(address indexed _to, uint256 _value);\r\n  event VipMigration(address indexed _vip, uint256 _value);\r\n  event newMember(address indexed _from);\r\n\r\n  // Token parameters\r\n  string public constant name = \"DXF - Decentralized eXperience Friends\";\r\n  string public constant symbol = \"DXF\";\r\n  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n  address public admin;\r\n  address public multisigDXF;\r\n\r\n  modifier onlyAdmin()\r\n  {\r\n    if (msg.sender!=admin) throw;\r\n    _;\r\n  }\r\n\r\n  function DXF_Tokens()\r\n  {\r\n    admin = msg.sender;\r\n    startingDateFunding=now;\r\n    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\r\n    //increment array by 1 for indexes\r\n    members.push(Member(0,0,0));\r\n  }\r\n\r\n\r\n  //empty fallback\r\n  function ()\r\n    {\r\n      throw;\r\n    }\r\n\r\n  //USER FUNCTIONS  \r\n  /// @notice Create tokens when funding is active.\r\n  /// @notice By using this function you accept the terms of DXF\r\n  /// @dev Required state: Funding Active\r\n  /// @dev State transition: -> Funding Success (only if cap reached)\r\n  function acceptTermsAndJoinDXF() payable external \r\n  {\r\n    // refuse if more than 12 months have passed\r\n    if (now>startingDateFunding+365 days) throw;\r\n    // Abort if DXF is not open.\r\n    if (!dxfOpen) throw;\r\n    // verify if the account is not a VIP account\r\n    if (vips[msg.sender]) throw;\r\n    // Do not allow creating less than 10 ether or more than the cap tokens.\r\n    if (msg.value < 10 ether) throw;\r\n    if (msg.value > (tokensCreationCap - totalTokens)) throw;\r\n    // Enforce cap of 10 000 ethers per address / individual\r\n    if (msg.value > (10000 ether - balances[msg.sender])) throw;\r\n    // Register member\r\n    if (balances[msg.sender]==0)\r\n      {\r\n        newMember(msg.sender); //event\r\n\tindexMembers[msg.sender]=members.length;\r\n\tmembers.push(Member(msg.sender,now,msg.value));\r\n      }\r\n    else\r\n      {\r\n\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\r\n      }\r\n    if (members.length>maxNumberMembers) throw;\r\n    //Send the funds to the MultiSig Wallet\r\n    if (multisigDXF==0) throw;\r\n    if (!multisigDXF.send(msg.value)) throw;\r\n    // Assign new tokens to the sender\r\n    uint numTokens = msg.value;\r\n    totalTokens += numTokens;\r\n    // Do not allow creating tokens if we don't leave enough for the VIPs\r\n    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\r\n    balances[msg.sender] += numTokens;\r\n    // Log token creation event\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n\r\n\r\n  //NOT INCLUDED IN LATEST VERSION\r\n  //since we move the funds to multisig\r\n  //refund will be with payback()\r\n  /* /// @notice Get back the ether sent during the funding in case the funding */\r\n  /* /// has not reached the minimum level. */\r\n  /* /// @dev Required state: refund true */\r\n  /* function refund() */\r\n  /* { */\r\n  /*   // Abort if not in refund state */\r\n  /*   if (!refundState) throw; */\r\n  /*   // Not refunded for VIP, we will do a manual refund for them */\r\n  /*   // via the payback function */\r\n  /*   if (vips[msg.sender]) throw; */\r\n  /*   uint value = balances[msg.sender]; */\r\n  /*   if (value == 0) throw; */\r\n  /*   balances[msg.sender] = 0; */\r\n  /*   totalTokens -= value; */\r\n  /*   delete members[indexMembers[msg.sender]]; */\r\n  /*   indexMembers[msg.sender]=0; */\r\n  /*   Refund(msg.sender, value); */\r\n  /*   if (!msg.sender.send(value)) throw; */\r\n  /* } */\r\n\r\n\r\n  //@notice Full Tranfer of DX tokens from sender to '_to'\r\n  //@dev only active if tranfer has been unlocked\r\n  //@param _to address of recipient\r\n  //@param _value amount to tranfer\r\n  //@return success of tranfer ?\r\n  function fullTransfer(address _to) returns (bool)\r\n  {\r\n    // Cancel if tranfer is not allowed\r\n    if (transferLocked) throw;\r\n    if (balances[_to]!=0) throw;\r\n    if (balances[msg.sender]!=0)\r\n      {\r\n\tuint senderBalance = balances[msg.sender];\r\n\tbalances[msg.sender] = 0;\r\n\tbalances[_to]=senderBalance;\r\n\tif (vips[msg.sender])\r\n\t  {\r\n\t    vips[_to]=true;\r\n\t    vips[msg.sender]=false;\r\n\t  }\r\n\tmembers[indexMembers[msg.sender]].member=_to;\r\n\tindexMembers[_to]=indexMembers[msg.sender];\r\n\tindexMembers[msg.sender]=0;\r\n\tTransfer(msg.sender, _to, senderBalance);\r\n\treturn true;\r\n      }\r\n    else\r\n      {\r\n\treturn false;\r\n      }\r\n  }\r\n\r\n\r\n  //ADMIN FUNCTIONS\r\n\r\n\r\n  //@notice called by Admin to manually register migration of previous DO\r\n  //@dev can not be called with a _vip address that is already investor\r\n  //@dev can be called even after the DO is sealed\r\n  //@param _value : balance of VIP at DXDO's creation date\r\n  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\r\n    onlyAdmin\r\n  {\r\n    if (_vip==0) throw;\r\n    if (_vip!=_vip_confirm) throw;\r\n    //don't allow migration to a non empty address\r\n    if (balances[_vip]!=0) throw; \r\n    if (_previous_balance==0) throw;\r\n    uint numberTokens=_previous_balance+(_previous_balance/3);\r\n    totalTokens+=numberTokens;\r\n    //too many tokens created via VIP migration\r\n    if (numberTokens>remainingTokensVIPs) throw;     \r\n    remainingTokensVIPs-=numberTokens;\r\n    balances[_vip]+=numberTokens;\r\n    indexMembers[_vip]=members.length;\r\n    members.push(Member(_vip,now,_previous_balance));\r\n    vips[_vip]=true;\r\n    VipMigration(_vip,_previous_balance);\r\n  }\r\n\r\n\r\n  /// @notice Pay back the ether contributed to the DAO\r\n  function paybackContribution(uint i)\r\n    payable\r\n    onlyAdmin\r\n  {\r\n    address memberRefunded=members[i].member;\r\n    if (memberRefunded==0) throw;\r\n    uint amountTokens=msg.value;\r\n    if (vips[memberRefunded]) \r\n      {\r\n\tamountTokens+=amountTokens/3;\r\n\tremainingTokensVIPs+=amountTokens;\r\n      }\r\n    if (amountTokens>balances[memberRefunded]) throw;\r\n    balances[memberRefunded]-=amountTokens;\r\n    totalTokens-=amountTokens;\r\n    if (balances[memberRefunded]==0) \r\n      {\r\n\tdelete members[i];\r\n\tvips[memberRefunded]=false;\r\n\tindexMembers[memberRefunded]=0;\r\n      }\r\n    if (!memberRefunded.send(msg.value))\r\n      {\r\n        failingRefund(memberRefunded,msg.value);\r\n      }\r\n    Refund(memberRefunded,msg.value);\r\n  }\r\n\r\n\r\n  function changeAdmin(address _admin, address _admin_confirm)\r\n    onlyAdmin\r\n  {\r\n    if (_admin!=_admin_confirm) throw;\r\n    if (_admin==0) throw;\r\n    admin=_admin;\r\n  }\r\n\r\n  //@notice called to seal the DO\r\n  //@dev can not be opened again, marks the end of the fundraising \r\n  //and the recruitment in the DO\r\n  function closeFunding()\r\n    onlyAdmin\r\n  {\r\n    closingDateFunding=now;\r\n    dxfOpen=false;\r\n    //verify if the cap has been reached\r\n    //if not : refund mode\r\n    if (totalTokens<tokensCreationMin)\r\n      {\r\n\trefundState=true;\r\n      }\r\n    else\r\n      {\r\n        //send balance, but should not be necessary.      \r\n\tif(!admin.send(this.balance)) throw;\r\n      }\r\n  }\r\n\r\n  //NOT INCLUDED\r\n  /* function reopenDO() */\r\n  /*   onlyAdmin */\r\n  /* { */\r\n  /*   dxfOpen=true; */\r\n  /*   transferLocked=true; */\r\n  /* } */\r\n\r\n  function allowTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=false;\r\n  }\r\n\r\n  function disableTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=true;\r\n  }\r\n\r\n\r\n  //Constant Functions\r\n  function totalSupply() external constant returns (uint256) \r\n  {\r\n    return totalTokens;\r\n  }\r\n\r\n  function balanceOf(address _owner) external constant returns (uint256) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \r\n  {\r\n    vip=vips[_owner];\r\n    balance_dxf=balances[_owner]/(1 ether);\r\n    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\r\n  }\r\n\r\n\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"refundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accountInformation\",\"outputs\":[{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"balance_dxf\",\"type\":\"uint256\"},{\"name\":\"share_dxf_per_thousands\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_admin_confirm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fullTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationVIPsCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"paybackContribution\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vip\",\"type\":\"address\"},{\"name\":\"_vip_confirm\",\"type\":\"address\"},{\"name\":\"_previous_balance\",\"type\":\"uint256\"}],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"initial_value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dxfOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigDXF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTermsAndJoinDXF\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensVIPs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"failingRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vip\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"VipMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"newMember\",\"type\":\"event\"}]",
        "ContractName": "DXF_Tokens",
        "CompilerVersion": "v0.4.6+commit.2dabbdf0",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x66d2a16ec82f4bd6e930a93abf82fa1f36a1768b",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.6;\r\n\r\ncontract DXF_Tokens{\r\n\r\n  //States\r\n  bool public dxfOpen=true;\r\n  bool public refundState;\r\n  bool public transferLocked=true;\r\n\r\n  uint256 public startingDateFunding;\r\n  uint256 public closingDateFunding;\r\n  //Maximum number of participants\r\n  uint256 public constant maxNumberMembers=5000;\r\n  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\r\n  uint256 public totalTokens;\r\n  uint256 public constant tokensCreationMin = 25000 ether;\r\n  uint256 public constant tokensCreationCap = 75000 ether;\r\n  //Cap of 12500 ethers worth of tokens to be distributed \r\n  //to previous DO members in exchange for their rouleth accounts\r\n  uint256 public remainingTokensVIPs=12500 ether;\r\n  uint256 public constant tokensCreationVIPsCap = 12500 ether; \r\n\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => bool) vips;\r\n  mapping (address => uint256) indexMembers;\r\n  \r\n  struct Member\r\n  {\r\n    address member;\r\n    uint timestamp;\r\n    uint initial_value;\r\n  }\r\n  Member[] public members;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event failingRefund(address indexed _to, uint256 _value);\r\n  event VipMigration(address indexed _vip, uint256 _value);\r\n  event newMember(address indexed _from);\r\n\r\n  // Token parameters\r\n  string public constant name = \"DXF - Decentralized eXperience Friends\";\r\n  string public constant symbol = \"DXF\";\r\n  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n  address public admin;\r\n  address public multisigDXF;\r\n\r\n  modifier onlyAdmin()\r\n  {\r\n    if (msg.sender!=admin) throw;\r\n    _;\r\n  }\r\n\r\n  function DXF_Tokens()\r\n  {\r\n    admin = msg.sender;\r\n    startingDateFunding=now;\r\n    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\r\n    //increment array by 1 for indexes\r\n    members.push(Member(0,0,0));\r\n  }\r\n\r\n\r\n  //empty fallback\r\n  function ()\r\n    {\r\n      throw;\r\n    }\r\n\r\n  //USER FUNCTIONS  \r\n  /// @notice Create tokens when funding is active.\r\n  /// @notice By using this function you accept the terms of DXF\r\n  /// @dev Required state: Funding Active\r\n  /// @dev State transition: -> Funding Success (only if cap reached)\r\n  function acceptTermsAndJoinDXF() payable external \r\n  {\r\n    // refuse if more than 12 months have passed\r\n    if (now>startingDateFunding+365 days) throw;\r\n    // Abort if DXF is not open.\r\n    if (!dxfOpen) throw;\r\n    // verify if the account is not a VIP account\r\n    if (vips[msg.sender]) throw;\r\n    // Do not allow creating less than 10 ether or more than the cap tokens.\r\n    if (msg.value < 10 ether) throw;\r\n    if (msg.value > (tokensCreationCap - totalTokens)) throw;\r\n    // Enforce cap of 10 000 ethers per address / individual\r\n    if (msg.value > (10000 ether - balances[msg.sender])) throw;\r\n    // Register member\r\n    if (balances[msg.sender]==0)\r\n      {\r\n        newMember(msg.sender); //event\r\n\tindexMembers[msg.sender]=members.length;\r\n\tmembers.push(Member(msg.sender,now,msg.value));\r\n      }\r\n    else\r\n      {\r\n\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\r\n      }\r\n    if (members.length>maxNumberMembers) throw;\r\n    //Send the funds to the MultiSig Wallet\r\n    if (multisigDXF==0) throw;\r\n    if (!multisigDXF.send(msg.value)) throw;\r\n    // Assign new tokens to the sender\r\n    uint numTokens = msg.value;\r\n    totalTokens += numTokens;\r\n    // Do not allow creating tokens if we don't leave enough for the VIPs\r\n    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\r\n    balances[msg.sender] += numTokens;\r\n    // Log token creation event\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n\r\n\r\n  //NOT INCLUDED IN LATEST VERSION\r\n  //since we move the funds to multisig\r\n  //refund will be with payback()\r\n  /* /// @notice Get back the ether sent during the funding in case the funding */\r\n  /* /// has not reached the minimum level. */\r\n  /* /// @dev Required state: refund true */\r\n  /* function refund() */\r\n  /* { */\r\n  /*   // Abort if not in refund state */\r\n  /*   if (!refundState) throw; */\r\n  /*   // Not refunded for VIP, we will do a manual refund for them */\r\n  /*   // via the payback function */\r\n  /*   if (vips[msg.sender]) throw; */\r\n  /*   uint value = balances[msg.sender]; */\r\n  /*   if (value == 0) throw; */\r\n  /*   balances[msg.sender] = 0; */\r\n  /*   totalTokens -= value; */\r\n  /*   delete members[indexMembers[msg.sender]]; */\r\n  /*   indexMembers[msg.sender]=0; */\r\n  /*   Refund(msg.sender, value); */\r\n  /*   if (!msg.sender.send(value)) throw; */\r\n  /* } */\r\n\r\n\r\n  //@notice Full Tranfer of DX tokens from sender to '_to'\r\n  //@dev only active if tranfer has been unlocked\r\n  //@param _to address of recipient\r\n  //@param _value amount to tranfer\r\n  //@return success of tranfer ?\r\n  function fullTransfer(address _to) returns (bool)\r\n  {\r\n    // Cancel if tranfer is not allowed\r\n    if (transferLocked) throw;\r\n    if (balances[_to]!=0) throw;\r\n    if (balances[msg.sender]!=0)\r\n      {\r\n\tuint senderBalance = balances[msg.sender];\r\n\tbalances[msg.sender] = 0;\r\n\tbalances[_to]=senderBalance;\r\n\tif (vips[msg.sender])\r\n\t  {\r\n\t    vips[_to]=true;\r\n\t    vips[msg.sender]=false;\r\n\t  }\r\n\tmembers[indexMembers[msg.sender]].member=_to;\r\n\tindexMembers[_to]=indexMembers[msg.sender];\r\n\tindexMembers[msg.sender]=0;\r\n\tTransfer(msg.sender, _to, senderBalance);\r\n\treturn true;\r\n      }\r\n    else\r\n      {\r\n\treturn false;\r\n      }\r\n  }\r\n\r\n\r\n  //ADMIN FUNCTIONS\r\n\r\n\r\n  //@notice called by Admin to manually register migration of previous DO\r\n  //@dev can not be called with a _vip address that is already investor\r\n  //@dev can be called even after the DO is sealed\r\n  //@param _value : balance of VIP at DXDO's creation date\r\n  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\r\n    onlyAdmin\r\n  {\r\n    if (_vip==0) throw;\r\n    if (_vip!=_vip_confirm) throw;\r\n    //don't allow migration to a non empty address\r\n    if (balances[_vip]!=0) throw; \r\n    if (_previous_balance==0) throw;\r\n    uint numberTokens=_previous_balance+(_previous_balance/3);\r\n    totalTokens+=numberTokens;\r\n    //too many tokens created via VIP migration\r\n    if (numberTokens>remainingTokensVIPs) throw;     \r\n    remainingTokensVIPs-=numberTokens;\r\n    balances[_vip]+=numberTokens;\r\n    indexMembers[_vip]=members.length;\r\n    members.push(Member(_vip,now,_previous_balance));\r\n    vips[_vip]=true;\r\n    VipMigration(_vip,_previous_balance);\r\n  }\r\n\r\n\r\n  /// @notice Pay back the ether contributed to the DAO\r\n  function paybackContribution(uint i)\r\n    payable\r\n    onlyAdmin\r\n  {\r\n    address memberRefunded=members[i].member;\r\n    if (memberRefunded==0) throw;\r\n    uint amountTokens=msg.value;\r\n    if (vips[memberRefunded]) \r\n      {\r\n\tamountTokens+=amountTokens/3;\r\n\tremainingTokensVIPs+=amountTokens;\r\n      }\r\n    if (amountTokens>balances[memberRefunded]) throw;\r\n    balances[memberRefunded]-=amountTokens;\r\n    totalTokens-=amountTokens;\r\n    if (balances[memberRefunded]==0) \r\n      {\r\n\tdelete members[i];\r\n\tvips[memberRefunded]=false;\r\n\tindexMembers[memberRefunded]=0;\r\n      }\r\n    if (!memberRefunded.send(msg.value))\r\n      {\r\n        failingRefund(memberRefunded,msg.value);\r\n      }\r\n    Refund(memberRefunded,msg.value);\r\n  }\r\n\r\n\r\n  function changeAdmin(address _admin, address _admin_confirm)\r\n    onlyAdmin\r\n  {\r\n    if (_admin!=_admin_confirm) throw;\r\n    if (_admin==0) throw;\r\n    admin=_admin;\r\n  }\r\n\r\n  //@notice called to seal the DO\r\n  //@dev can not be opened again, marks the end of the fundraising \r\n  //and the recruitment in the DO\r\n  function closeFunding()\r\n    onlyAdmin\r\n  {\r\n    closingDateFunding=now;\r\n    dxfOpen=false;\r\n    //verify if the cap has been reached\r\n    //if not : refund mode\r\n    if (totalTokens<tokensCreationMin)\r\n      {\r\n\trefundState=true;\r\n      }\r\n    else\r\n      {\r\n        //send balance, but should not be necessary.      \r\n\tif(!admin.send(this.balance)) throw;\r\n      }\r\n  }\r\n\r\n  //NOT INCLUDED\r\n  /* function reopenDO() */\r\n  /*   onlyAdmin */\r\n  /* { */\r\n  /*   dxfOpen=true; */\r\n  /*   transferLocked=true; */\r\n  /* } */\r\n\r\n  function allowTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=false;\r\n  }\r\n\r\n  function disableTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=true;\r\n  }\r\n\r\n\r\n  //Constant Functions\r\n  function totalSupply() external constant returns (uint256) \r\n  {\r\n    return totalTokens;\r\n  }\r\n\r\n  function balanceOf(address _owner) external constant returns (uint256) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \r\n  {\r\n    vip=vips[_owner];\r\n    balance_dxf=balances[_owner]/(1 ether);\r\n    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\r\n  }\r\n\r\n\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"refundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accountInformation\",\"outputs\":[{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"balance_dxf\",\"type\":\"uint256\"},{\"name\":\"share_dxf_per_thousands\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_admin_confirm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fullTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationVIPsCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"paybackContribution\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vip\",\"type\":\"address\"},{\"name\":\"_vip_confirm\",\"type\":\"address\"},{\"name\":\"_previous_balance\",\"type\":\"uint256\"}],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"initial_value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dxfOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigDXF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTermsAndJoinDXF\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensVIPs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"failingRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vip\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"VipMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"newMember\",\"type\":\"event\"}]",
        "ContractName": "DXF_Tokens",
        "CompilerVersion": "v0.4.6+commit.2dabbdf0",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe975f6c744054c6ee4c3da475e7f66b683208085",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.6;\r\n\r\ncontract DXF_Tokens{\r\n\r\n  //States\r\n  bool public dxfOpen=true;\r\n  bool public refundState;\r\n  bool public transferLocked=true;\r\n\r\n  uint256 public startingDateFunding;\r\n  uint256 public closingDateFunding;\r\n  //Maximum number of participants\r\n  uint256 public constant maxNumberMembers=5000;\r\n  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\r\n  uint256 public totalTokens;\r\n  uint256 public constant tokensCreationMin = 25000 ether;\r\n  uint256 public constant tokensCreationCap = 75000 ether;\r\n  //Cap of 12500 ethers worth of tokens to be distributed \r\n  //to previous DO members in exchange for their rouleth accounts\r\n  uint256 public remainingTokensVIPs=12500 ether;\r\n  uint256 public constant tokensCreationVIPsCap = 12500 ether; \r\n\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => bool) vips;\r\n  mapping (address => uint256) indexMembers;\r\n  \r\n  struct Member\r\n  {\r\n    address member;\r\n    uint timestamp;\r\n    uint initial_value;\r\n  }\r\n  Member[] public members;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event failingRefund(address indexed _to, uint256 _value);\r\n  event VipMigration(address indexed _vip, uint256 _value);\r\n  event newMember(address indexed _from);\r\n\r\n  // Token parameters\r\n  string public constant name = \"DXF - Decentralized eXperience Friends\";\r\n  string public constant symbol = \"DXF\";\r\n  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n  address public admin;\r\n  address public multisigDXF;\r\n\r\n  modifier onlyAdmin()\r\n  {\r\n    if (msg.sender!=admin) throw;\r\n    _;\r\n  }\r\n\r\n  function DXF_Tokens()\r\n  {\r\n    admin = msg.sender;\r\n    startingDateFunding=now;\r\n    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\r\n    //increment array by 1 for indexes\r\n    members.push(Member(0,0,0));\r\n  }\r\n\r\n\r\n  //empty fallback\r\n  function ()\r\n    {\r\n      throw;\r\n    }\r\n\r\n  //USER FUNCTIONS  \r\n  /// @notice Create tokens when funding is active.\r\n  /// @notice By using this function you accept the terms of DXF\r\n  /// @dev Required state: Funding Active\r\n  /// @dev State transition: -> Funding Success (only if cap reached)\r\n  function acceptTermsAndJoinDXF() payable external \r\n  {\r\n    // refuse if more than 12 months have passed\r\n    if (now>startingDateFunding+365 days) throw;\r\n    // Abort if DXF is not open.\r\n    if (!dxfOpen) throw;\r\n    // verify if the account is not a VIP account\r\n    if (vips[msg.sender]) throw;\r\n    // Do not allow creating less than 10 ether or more than the cap tokens.\r\n    if (msg.value < 10 ether) throw;\r\n    if (msg.value > (tokensCreationCap - totalTokens)) throw;\r\n    // Enforce cap of 10 000 ethers per address / individual\r\n    if (msg.value > (10000 ether - balances[msg.sender])) throw;\r\n    // Register member\r\n    if (balances[msg.sender]==0)\r\n      {\r\n        newMember(msg.sender); //event\r\n\tindexMembers[msg.sender]=members.length;\r\n\tmembers.push(Member(msg.sender,now,msg.value));\r\n      }\r\n    else\r\n      {\r\n\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\r\n      }\r\n    if (members.length>maxNumberMembers) throw;\r\n    //Send the funds to the MultiSig Wallet\r\n    if (multisigDXF==0) throw;\r\n    if (!multisigDXF.send(msg.value)) throw;\r\n    // Assign new tokens to the sender\r\n    uint numTokens = msg.value;\r\n    totalTokens += numTokens;\r\n    // Do not allow creating tokens if we don't leave enough for the VIPs\r\n    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\r\n    balances[msg.sender] += numTokens;\r\n    // Log token creation event\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n\r\n\r\n  //NOT INCLUDED IN LATEST VERSION\r\n  //since we move the funds to multisig\r\n  //refund will be with payback()\r\n  /* /// @notice Get back the ether sent during the funding in case the funding */\r\n  /* /// has not reached the minimum level. */\r\n  /* /// @dev Required state: refund true */\r\n  /* function refund() */\r\n  /* { */\r\n  /*   // Abort if not in refund state */\r\n  /*   if (!refundState) throw; */\r\n  /*   // Not refunded for VIP, we will do a manual refund for them */\r\n  /*   // via the payback function */\r\n  /*   if (vips[msg.sender]) throw; */\r\n  /*   uint value = balances[msg.sender]; */\r\n  /*   if (value == 0) throw; */\r\n  /*   balances[msg.sender] = 0; */\r\n  /*   totalTokens -= value; */\r\n  /*   delete members[indexMembers[msg.sender]]; */\r\n  /*   indexMembers[msg.sender]=0; */\r\n  /*   Refund(msg.sender, value); */\r\n  /*   if (!msg.sender.send(value)) throw; */\r\n  /* } */\r\n\r\n\r\n  //@notice Full Tranfer of DX tokens from sender to '_to'\r\n  //@dev only active if tranfer has been unlocked\r\n  //@param _to address of recipient\r\n  //@param _value amount to tranfer\r\n  //@return success of tranfer ?\r\n  function fullTransfer(address _to) returns (bool)\r\n  {\r\n    // Cancel if tranfer is not allowed\r\n    if (transferLocked) throw;\r\n    if (balances[_to]!=0) throw;\r\n    if (balances[msg.sender]!=0)\r\n      {\r\n\tuint senderBalance = balances[msg.sender];\r\n\tbalances[msg.sender] = 0;\r\n\tbalances[_to]=senderBalance;\r\n\tif (vips[msg.sender])\r\n\t  {\r\n\t    vips[_to]=true;\r\n\t    vips[msg.sender]=false;\r\n\t  }\r\n\tmembers[indexMembers[msg.sender]].member=_to;\r\n\tindexMembers[_to]=indexMembers[msg.sender];\r\n\tindexMembers[msg.sender]=0;\r\n\tTransfer(msg.sender, _to, senderBalance);\r\n\treturn true;\r\n      }\r\n    else\r\n      {\r\n\treturn false;\r\n      }\r\n  }\r\n\r\n\r\n  //ADMIN FUNCTIONS\r\n\r\n\r\n  //@notice called by Admin to manually register migration of previous DO\r\n  //@dev can not be called with a _vip address that is already investor\r\n  //@dev can be called even after the DO is sealed\r\n  //@param _value : balance of VIP at DXDO's creation date\r\n  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\r\n    onlyAdmin\r\n  {\r\n    if (_vip==0) throw;\r\n    if (_vip!=_vip_confirm) throw;\r\n    //don't allow migration to a non empty address\r\n    if (balances[_vip]!=0) throw; \r\n    if (_previous_balance==0) throw;\r\n    uint numberTokens=_previous_balance+(_previous_balance/3);\r\n    totalTokens+=numberTokens;\r\n    //too many tokens created via VIP migration\r\n    if (numberTokens>remainingTokensVIPs) throw;     \r\n    remainingTokensVIPs-=numberTokens;\r\n    balances[_vip]+=numberTokens;\r\n    indexMembers[_vip]=members.length;\r\n    members.push(Member(_vip,now,_previous_balance));\r\n    vips[_vip]=true;\r\n    VipMigration(_vip,_previous_balance);\r\n  }\r\n\r\n\r\n  /// @notice Pay back the ether contributed to the DAO\r\n  function paybackContribution(uint i)\r\n    payable\r\n    onlyAdmin\r\n  {\r\n    address memberRefunded=members[i].member;\r\n    if (memberRefunded==0) throw;\r\n    uint amountTokens=msg.value;\r\n    if (vips[memberRefunded]) \r\n      {\r\n\tamountTokens+=amountTokens/3;\r\n\tremainingTokensVIPs+=amountTokens;\r\n      }\r\n    if (amountTokens>balances[memberRefunded]) throw;\r\n    balances[memberRefunded]-=amountTokens;\r\n    totalTokens-=amountTokens;\r\n    if (balances[memberRefunded]==0) \r\n      {\r\n\tdelete members[i];\r\n\tvips[memberRefunded]=false;\r\n\tindexMembers[memberRefunded]=0;\r\n      }\r\n    if (!memberRefunded.send(msg.value))\r\n      {\r\n        failingRefund(memberRefunded,msg.value);\r\n      }\r\n    Refund(memberRefunded,msg.value);\r\n  }\r\n\r\n\r\n  function changeAdmin(address _admin, address _admin_confirm)\r\n    onlyAdmin\r\n  {\r\n    if (_admin!=_admin_confirm) throw;\r\n    if (_admin==0) throw;\r\n    admin=_admin;\r\n  }\r\n\r\n  //@notice called to seal the DO\r\n  //@dev can not be opened again, marks the end of the fundraising \r\n  //and the recruitment in the DO\r\n  function closeFunding()\r\n    onlyAdmin\r\n  {\r\n    closingDateFunding=now;\r\n    dxfOpen=false;\r\n    //verify if the cap has been reached\r\n    //if not : refund mode\r\n    if (totalTokens<tokensCreationMin)\r\n      {\r\n\trefundState=true;\r\n      }\r\n    else\r\n      {\r\n        //send balance, but should not be necessary.      \r\n\tif(!admin.send(this.balance)) throw;\r\n      }\r\n  }\r\n\r\n  //NOT INCLUDED\r\n  /* function reopenDO() */\r\n  /*   onlyAdmin */\r\n  /* { */\r\n  /*   dxfOpen=true; */\r\n  /*   transferLocked=true; */\r\n  /* } */\r\n\r\n  function allowTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=false;\r\n  }\r\n\r\n  function disableTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=true;\r\n  }\r\n\r\n\r\n  //Constant Functions\r\n  function totalSupply() external constant returns (uint256) \r\n  {\r\n    return totalTokens;\r\n  }\r\n\r\n  function balanceOf(address _owner) external constant returns (uint256) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \r\n  {\r\n    vip=vips[_owner];\r\n    balance_dxf=balances[_owner]/(1 ether);\r\n    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\r\n  }\r\n\r\n\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"refundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accountInformation\",\"outputs\":[{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"balance_dxf\",\"type\":\"uint256\"},{\"name\":\"share_dxf_per_thousands\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_admin_confirm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fullTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationVIPsCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"paybackContribution\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vip\",\"type\":\"address\"},{\"name\":\"_vip_confirm\",\"type\":\"address\"},{\"name\":\"_previous_balance\",\"type\":\"uint256\"}],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"initial_value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dxfOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigDXF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTermsAndJoinDXF\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensVIPs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"failingRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vip\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"VipMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"newMember\",\"type\":\"event\"}]",
        "ContractName": "DXF_Tokens",
        "CompilerVersion": "v0.4.6+commit.2dabbdf0",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x111df3f3fa069587c51a9b613f6271eb47e15594",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.6;\r\n\r\ncontract DXF_Tokens{\r\n\r\n  //States\r\n  bool public dxfOpen=true;\r\n  bool public refundState;\r\n  bool public transferLocked=true;\r\n\r\n  uint256 public startingDateFunding;\r\n  uint256 public closingDateFunding;\r\n  //Maximum number of participants\r\n  uint256 public constant maxNumberMembers=5000;\r\n  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\r\n  uint256 public totalTokens;\r\n  uint256 public constant tokensCreationMin = 25000 ether;\r\n  uint256 public constant tokensCreationCap = 75000 ether;\r\n  //Cap of 12500 ethers worth of tokens to be distributed \r\n  //to previous DO members in exchange for their rouleth accounts\r\n  uint256 public remainingTokensVIPs=12500 ether;\r\n  uint256 public constant tokensCreationVIPsCap = 12500 ether; \r\n\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => bool) vips;\r\n  mapping (address => uint256) indexMembers;\r\n  \r\n  struct Member\r\n  {\r\n    address member;\r\n    uint timestamp;\r\n    uint initial_value;\r\n  }\r\n  Member[] public members;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event failingRefund(address indexed _to, uint256 _value);\r\n  event VipMigration(address indexed _vip, uint256 _value);\r\n  event newMember(address indexed _from);\r\n\r\n  // Token parameters\r\n  string public constant name = \"DXF - Decentralized eXperience Friends\";\r\n  string public constant symbol = \"DXF\";\r\n  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n  address public admin;\r\n  address public multisigDXF;\r\n\r\n  modifier onlyAdmin()\r\n  {\r\n    if (msg.sender!=admin) throw;\r\n    _;\r\n  }\r\n\r\n  function DXF_Tokens()\r\n  {\r\n    admin = msg.sender;\r\n    startingDateFunding=now;\r\n    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\r\n    //increment array by 1 for indexes\r\n    members.push(Member(0,0,0));\r\n  }\r\n\r\n\r\n  //empty fallback\r\n  function ()\r\n    {\r\n      throw;\r\n    }\r\n\r\n  //USER FUNCTIONS  \r\n  /// @notice Create tokens when funding is active.\r\n  /// @notice By using this function you accept the terms of DXF\r\n  /// @dev Required state: Funding Active\r\n  /// @dev State transition: -> Funding Success (only if cap reached)\r\n  function acceptTermsAndJoinDXF() payable external \r\n  {\r\n    // refuse if more than 12 months have passed\r\n    if (now>startingDateFunding+365 days) throw;\r\n    // Abort if DXF is not open.\r\n    if (!dxfOpen) throw;\r\n    // verify if the account is not a VIP account\r\n    if (vips[msg.sender]) throw;\r\n    // Do not allow creating less than 10 ether or more than the cap tokens.\r\n    if (msg.value < 10 ether) throw;\r\n    if (msg.value > (tokensCreationCap - totalTokens)) throw;\r\n    // Enforce cap of 10 000 ethers per address / individual\r\n    if (msg.value > (10000 ether - balances[msg.sender])) throw;\r\n    // Register member\r\n    if (balances[msg.sender]==0)\r\n      {\r\n        newMember(msg.sender); //event\r\n\tindexMembers[msg.sender]=members.length;\r\n\tmembers.push(Member(msg.sender,now,msg.value));\r\n      }\r\n    else\r\n      {\r\n\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\r\n      }\r\n    if (members.length>maxNumberMembers) throw;\r\n    //Send the funds to the MultiSig Wallet\r\n    if (multisigDXF==0) throw;\r\n    if (!multisigDXF.send(msg.value)) throw;\r\n    // Assign new tokens to the sender\r\n    uint numTokens = msg.value;\r\n    totalTokens += numTokens;\r\n    // Do not allow creating tokens if we don't leave enough for the VIPs\r\n    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\r\n    balances[msg.sender] += numTokens;\r\n    // Log token creation event\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n\r\n\r\n  //NOT INCLUDED IN LATEST VERSION\r\n  //since we move the funds to multisig\r\n  //refund will be with payback()\r\n  /* /// @notice Get back the ether sent during the funding in case the funding */\r\n  /* /// has not reached the minimum level. */\r\n  /* /// @dev Required state: refund true */\r\n  /* function refund() */\r\n  /* { */\r\n  /*   // Abort if not in refund state */\r\n  /*   if (!refundState) throw; */\r\n  /*   // Not refunded for VIP, we will do a manual refund for them */\r\n  /*   // via the payback function */\r\n  /*   if (vips[msg.sender]) throw; */\r\n  /*   uint value = balances[msg.sender]; */\r\n  /*   if (value == 0) throw; */\r\n  /*   balances[msg.sender] = 0; */\r\n  /*   totalTokens -= value; */\r\n  /*   delete members[indexMembers[msg.sender]]; */\r\n  /*   indexMembers[msg.sender]=0; */\r\n  /*   Refund(msg.sender, value); */\r\n  /*   if (!msg.sender.send(value)) throw; */\r\n  /* } */\r\n\r\n\r\n  //@notice Full Tranfer of DX tokens from sender to '_to'\r\n  //@dev only active if tranfer has been unlocked\r\n  //@param _to address of recipient\r\n  //@param _value amount to tranfer\r\n  //@return success of tranfer ?\r\n  function fullTransfer(address _to) returns (bool)\r\n  {\r\n    // Cancel if tranfer is not allowed\r\n    if (transferLocked) throw;\r\n    if (balances[_to]!=0) throw;\r\n    if (balances[msg.sender]!=0)\r\n      {\r\n\tuint senderBalance = balances[msg.sender];\r\n\tbalances[msg.sender] = 0;\r\n\tbalances[_to]=senderBalance;\r\n\tif (vips[msg.sender])\r\n\t  {\r\n\t    vips[_to]=true;\r\n\t    vips[msg.sender]=false;\r\n\t  }\r\n\tmembers[indexMembers[msg.sender]].member=_to;\r\n\tindexMembers[_to]=indexMembers[msg.sender];\r\n\tindexMembers[msg.sender]=0;\r\n\tTransfer(msg.sender, _to, senderBalance);\r\n\treturn true;\r\n      }\r\n    else\r\n      {\r\n\treturn false;\r\n      }\r\n  }\r\n\r\n\r\n  //ADMIN FUNCTIONS\r\n\r\n\r\n  //@notice called by Admin to manually register migration of previous DO\r\n  //@dev can not be called with a _vip address that is already investor\r\n  //@dev can be called even after the DO is sealed\r\n  //@param _value : balance of VIP at DXDO's creation date\r\n  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\r\n    onlyAdmin\r\n  {\r\n    if (_vip==0) throw;\r\n    if (_vip!=_vip_confirm) throw;\r\n    //don't allow migration to a non empty address\r\n    if (balances[_vip]!=0) throw; \r\n    if (_previous_balance==0) throw;\r\n    uint numberTokens=_previous_balance+(_previous_balance/3);\r\n    totalTokens+=numberTokens;\r\n    //too many tokens created via VIP migration\r\n    if (numberTokens>remainingTokensVIPs) throw;     \r\n    remainingTokensVIPs-=numberTokens;\r\n    balances[_vip]+=numberTokens;\r\n    indexMembers[_vip]=members.length;\r\n    members.push(Member(_vip,now,_previous_balance));\r\n    vips[_vip]=true;\r\n    VipMigration(_vip,_previous_balance);\r\n  }\r\n\r\n\r\n  /// @notice Pay back the ether contributed to the DAO\r\n  function paybackContribution(uint i)\r\n    payable\r\n    onlyAdmin\r\n  {\r\n    address memberRefunded=members[i].member;\r\n    if (memberRefunded==0) throw;\r\n    uint amountTokens=msg.value;\r\n    if (vips[memberRefunded]) \r\n      {\r\n\tamountTokens+=amountTokens/3;\r\n\tremainingTokensVIPs+=amountTokens;\r\n      }\r\n    if (amountTokens>balances[memberRefunded]) throw;\r\n    balances[memberRefunded]-=amountTokens;\r\n    totalTokens-=amountTokens;\r\n    if (balances[memberRefunded]==0) \r\n      {\r\n\tdelete members[i];\r\n\tvips[memberRefunded]=false;\r\n\tindexMembers[memberRefunded]=0;\r\n      }\r\n    if (!memberRefunded.send(msg.value))\r\n      {\r\n        failingRefund(memberRefunded,msg.value);\r\n      }\r\n    Refund(memberRefunded,msg.value);\r\n  }\r\n\r\n\r\n  function changeAdmin(address _admin, address _admin_confirm)\r\n    onlyAdmin\r\n  {\r\n    if (_admin!=_admin_confirm) throw;\r\n    if (_admin==0) throw;\r\n    admin=_admin;\r\n  }\r\n\r\n  //@notice called to seal the DO\r\n  //@dev can not be opened again, marks the end of the fundraising \r\n  //and the recruitment in the DO\r\n  function closeFunding()\r\n    onlyAdmin\r\n  {\r\n    closingDateFunding=now;\r\n    dxfOpen=false;\r\n    //verify if the cap has been reached\r\n    //if not : refund mode\r\n    if (totalTokens<tokensCreationMin)\r\n      {\r\n\trefundState=true;\r\n      }\r\n    else\r\n      {\r\n        //send balance, but should not be necessary.      \r\n\tif(!admin.send(this.balance)) throw;\r\n      }\r\n  }\r\n\r\n  //NOT INCLUDED\r\n  /* function reopenDO() */\r\n  /*   onlyAdmin */\r\n  /* { */\r\n  /*   dxfOpen=true; */\r\n  /*   transferLocked=true; */\r\n  /* } */\r\n\r\n  function allowTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=false;\r\n  }\r\n\r\n  function disableTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=true;\r\n  }\r\n\r\n\r\n  //Constant Functions\r\n  function totalSupply() external constant returns (uint256) \r\n  {\r\n    return totalTokens;\r\n  }\r\n\r\n  function balanceOf(address _owner) external constant returns (uint256) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \r\n  {\r\n    vip=vips[_owner];\r\n    balance_dxf=balances[_owner]/(1 ether);\r\n    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\r\n  }\r\n\r\n\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"refundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accountInformation\",\"outputs\":[{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"balance_dxf\",\"type\":\"uint256\"},{\"name\":\"share_dxf_per_thousands\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_admin_confirm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fullTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationVIPsCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"paybackContribution\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vip\",\"type\":\"address\"},{\"name\":\"_vip_confirm\",\"type\":\"address\"},{\"name\":\"_previous_balance\",\"type\":\"uint256\"}],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"initial_value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dxfOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigDXF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTermsAndJoinDXF\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensVIPs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"failingRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vip\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"VipMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"newMember\",\"type\":\"event\"}]",
        "ContractName": "DXF_Tokens",
        "CompilerVersion": "v0.4.6+commit.2dabbdf0",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb92c458422f9d4d7e006f5d5619f7709b8223c55",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.6;\r\n\r\ncontract DXF_Tokens{\r\n\r\n  //States\r\n  bool public dxfOpen=true;\r\n  bool public refundState;\r\n  bool public transferLocked=true;\r\n\r\n  uint256 public startingDateFunding;\r\n  uint256 public closingDateFunding;\r\n  //Maximum number of participants\r\n  uint256 public constant maxNumberMembers=5000;\r\n  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\r\n  uint256 public totalTokens;\r\n  uint256 public constant tokensCreationMin = 25000 ether;\r\n  uint256 public constant tokensCreationCap = 75000 ether;\r\n  //Cap of 12500 ethers worth of tokens to be distributed \r\n  //to previous DO members in exchange for their rouleth accounts\r\n  uint256 public remainingTokensVIPs=12500 ether;\r\n  uint256 public constant tokensCreationVIPsCap = 12500 ether; \r\n\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => bool) vips;\r\n  mapping (address => uint256) indexMembers;\r\n  \r\n  struct Member\r\n  {\r\n    address member;\r\n    uint timestamp;\r\n    uint initial_value;\r\n  }\r\n  Member[] public members;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event failingRefund(address indexed _to, uint256 _value);\r\n  event VipMigration(address indexed _vip, uint256 _value);\r\n  event newMember(address indexed _from);\r\n\r\n  // Token parameters\r\n  string public constant name = \"DXF - Decentralized eXperience Friends\";\r\n  string public constant symbol = \"DXF\";\r\n  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n  address public admin;\r\n  address public multisigDXF;\r\n\r\n  modifier onlyAdmin()\r\n  {\r\n    if (msg.sender!=admin) throw;\r\n    _;\r\n  }\r\n\r\n  function DXF_Tokens()\r\n  {\r\n    admin = msg.sender;\r\n    startingDateFunding=now;\r\n    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\r\n    //increment array by 1 for indexes\r\n    members.push(Member(0,0,0));\r\n  }\r\n\r\n\r\n  //empty fallback\r\n  function ()\r\n    {\r\n      throw;\r\n    }\r\n\r\n  //USER FUNCTIONS  \r\n  /// @notice Create tokens when funding is active.\r\n  /// @notice By using this function you accept the terms of DXF\r\n  /// @dev Required state: Funding Active\r\n  /// @dev State transition: -> Funding Success (only if cap reached)\r\n  function acceptTermsAndJoinDXF() payable external \r\n  {\r\n    // refuse if more than 12 months have passed\r\n    if (now>startingDateFunding+365 days) throw;\r\n    // Abort if DXF is not open.\r\n    if (!dxfOpen) throw;\r\n    // verify if the account is not a VIP account\r\n    if (vips[msg.sender]) throw;\r\n    // Do not allow creating less than 10 ether or more than the cap tokens.\r\n    if (msg.value < 10 ether) throw;\r\n    if (msg.value > (tokensCreationCap - totalTokens)) throw;\r\n    // Enforce cap of 10 000 ethers per address / individual\r\n    if (msg.value > (10000 ether - balances[msg.sender])) throw;\r\n    // Register member\r\n    if (balances[msg.sender]==0)\r\n      {\r\n        newMember(msg.sender); //event\r\n\tindexMembers[msg.sender]=members.length;\r\n\tmembers.push(Member(msg.sender,now,msg.value));\r\n      }\r\n    else\r\n      {\r\n\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\r\n      }\r\n    if (members.length>maxNumberMembers) throw;\r\n    //Send the funds to the MultiSig Wallet\r\n    if (multisigDXF==0) throw;\r\n    if (!multisigDXF.send(msg.value)) throw;\r\n    // Assign new tokens to the sender\r\n    uint numTokens = msg.value;\r\n    totalTokens += numTokens;\r\n    // Do not allow creating tokens if we don't leave enough for the VIPs\r\n    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\r\n    balances[msg.sender] += numTokens;\r\n    // Log token creation event\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n\r\n\r\n  //NOT INCLUDED IN LATEST VERSION\r\n  //since we move the funds to multisig\r\n  //refund will be with payback()\r\n  /* /// @notice Get back the ether sent during the funding in case the funding */\r\n  /* /// has not reached the minimum level. */\r\n  /* /// @dev Required state: refund true */\r\n  /* function refund() */\r\n  /* { */\r\n  /*   // Abort if not in refund state */\r\n  /*   if (!refundState) throw; */\r\n  /*   // Not refunded for VIP, we will do a manual refund for them */\r\n  /*   // via the payback function */\r\n  /*   if (vips[msg.sender]) throw; */\r\n  /*   uint value = balances[msg.sender]; */\r\n  /*   if (value == 0) throw; */\r\n  /*   balances[msg.sender] = 0; */\r\n  /*   totalTokens -= value; */\r\n  /*   delete members[indexMembers[msg.sender]]; */\r\n  /*   indexMembers[msg.sender]=0; */\r\n  /*   Refund(msg.sender, value); */\r\n  /*   if (!msg.sender.send(value)) throw; */\r\n  /* } */\r\n\r\n\r\n  //@notice Full Tranfer of DX tokens from sender to '_to'\r\n  //@dev only active if tranfer has been unlocked\r\n  //@param _to address of recipient\r\n  //@param _value amount to tranfer\r\n  //@return success of tranfer ?\r\n  function fullTransfer(address _to) returns (bool)\r\n  {\r\n    // Cancel if tranfer is not allowed\r\n    if (transferLocked) throw;\r\n    if (balances[_to]!=0) throw;\r\n    if (balances[msg.sender]!=0)\r\n      {\r\n\tuint senderBalance = balances[msg.sender];\r\n\tbalances[msg.sender] = 0;\r\n\tbalances[_to]=senderBalance;\r\n\tif (vips[msg.sender])\r\n\t  {\r\n\t    vips[_to]=true;\r\n\t    vips[msg.sender]=false;\r\n\t  }\r\n\tmembers[indexMembers[msg.sender]].member=_to;\r\n\tindexMembers[_to]=indexMembers[msg.sender];\r\n\tindexMembers[msg.sender]=0;\r\n\tTransfer(msg.sender, _to, senderBalance);\r\n\treturn true;\r\n      }\r\n    else\r\n      {\r\n\treturn false;\r\n      }\r\n  }\r\n\r\n\r\n  //ADMIN FUNCTIONS\r\n\r\n\r\n  //@notice called by Admin to manually register migration of previous DO\r\n  //@dev can not be called with a _vip address that is already investor\r\n  //@dev can be called even after the DO is sealed\r\n  //@param _value : balance of VIP at DXDO's creation date\r\n  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\r\n    onlyAdmin\r\n  {\r\n    if (_vip==0) throw;\r\n    if (_vip!=_vip_confirm) throw;\r\n    //don't allow migration to a non empty address\r\n    if (balances[_vip]!=0) throw; \r\n    if (_previous_balance==0) throw;\r\n    uint numberTokens=_previous_balance+(_previous_balance/3);\r\n    totalTokens+=numberTokens;\r\n    //too many tokens created via VIP migration\r\n    if (numberTokens>remainingTokensVIPs) throw;     \r\n    remainingTokensVIPs-=numberTokens;\r\n    balances[_vip]+=numberTokens;\r\n    indexMembers[_vip]=members.length;\r\n    members.push(Member(_vip,now,_previous_balance));\r\n    vips[_vip]=true;\r\n    VipMigration(_vip,_previous_balance);\r\n  }\r\n\r\n\r\n  /// @notice Pay back the ether contributed to the DAO\r\n  function paybackContribution(uint i)\r\n    payable\r\n    onlyAdmin\r\n  {\r\n    address memberRefunded=members[i].member;\r\n    if (memberRefunded==0) throw;\r\n    uint amountTokens=msg.value;\r\n    if (vips[memberRefunded]) \r\n      {\r\n\tamountTokens+=amountTokens/3;\r\n\tremainingTokensVIPs+=amountTokens;\r\n      }\r\n    if (amountTokens>balances[memberRefunded]) throw;\r\n    balances[memberRefunded]-=amountTokens;\r\n    totalTokens-=amountTokens;\r\n    if (balances[memberRefunded]==0) \r\n      {\r\n\tdelete members[i];\r\n\tvips[memberRefunded]=false;\r\n\tindexMembers[memberRefunded]=0;\r\n      }\r\n    if (!memberRefunded.send(msg.value))\r\n      {\r\n        failingRefund(memberRefunded,msg.value);\r\n      }\r\n    Refund(memberRefunded,msg.value);\r\n  }\r\n\r\n\r\n  function changeAdmin(address _admin, address _admin_confirm)\r\n    onlyAdmin\r\n  {\r\n    if (_admin!=_admin_confirm) throw;\r\n    if (_admin==0) throw;\r\n    admin=_admin;\r\n  }\r\n\r\n  //@notice called to seal the DO\r\n  //@dev can not be opened again, marks the end of the fundraising \r\n  //and the recruitment in the DO\r\n  function closeFunding()\r\n    onlyAdmin\r\n  {\r\n    closingDateFunding=now;\r\n    dxfOpen=false;\r\n    //verify if the cap has been reached\r\n    //if not : refund mode\r\n    if (totalTokens<tokensCreationMin)\r\n      {\r\n\trefundState=true;\r\n      }\r\n    else\r\n      {\r\n        //send balance, but should not be necessary.      \r\n\tif(!admin.send(this.balance)) throw;\r\n      }\r\n  }\r\n\r\n  //NOT INCLUDED\r\n  /* function reopenDO() */\r\n  /*   onlyAdmin */\r\n  /* { */\r\n  /*   dxfOpen=true; */\r\n  /*   transferLocked=true; */\r\n  /* } */\r\n\r\n  function allowTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=false;\r\n  }\r\n\r\n  function disableTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=true;\r\n  }\r\n\r\n\r\n  //Constant Functions\r\n  function totalSupply() external constant returns (uint256) \r\n  {\r\n    return totalTokens;\r\n  }\r\n\r\n  function balanceOf(address _owner) external constant returns (uint256) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \r\n  {\r\n    vip=vips[_owner];\r\n    balance_dxf=balances[_owner]/(1 ether);\r\n    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\r\n  }\r\n\r\n\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"refundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accountInformation\",\"outputs\":[{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"balance_dxf\",\"type\":\"uint256\"},{\"name\":\"share_dxf_per_thousands\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_admin_confirm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fullTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationVIPsCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"paybackContribution\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vip\",\"type\":\"address\"},{\"name\":\"_vip_confirm\",\"type\":\"address\"},{\"name\":\"_previous_balance\",\"type\":\"uint256\"}],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"initial_value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dxfOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigDXF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTermsAndJoinDXF\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensVIPs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"failingRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vip\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"VipMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"newMember\",\"type\":\"event\"}]",
        "ContractName": "DXF_Tokens",
        "CompilerVersion": "v0.4.6+commit.2dabbdf0",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcbc1d9b1f18cc9dfcb95a68830b2c66b647a221d",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.6;\r\n\r\ncontract DXF_Tokens{\r\n\r\n  //States\r\n  bool public dxfOpen=true;\r\n  bool public refundState;\r\n  bool public transferLocked=true;\r\n\r\n  uint256 public startingDateFunding;\r\n  uint256 public closingDateFunding;\r\n  //Maximum number of participants\r\n  uint256 public constant maxNumberMembers=5000;\r\n  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\r\n  uint256 public totalTokens;\r\n  uint256 public constant tokensCreationMin = 25000 ether;\r\n  uint256 public constant tokensCreationCap = 75000 ether;\r\n  //Cap of 12500 ethers worth of tokens to be distributed \r\n  //to previous DO members in exchange for their rouleth accounts\r\n  uint256 public remainingTokensVIPs=12500 ether;\r\n  uint256 public constant tokensCreationVIPsCap = 12500 ether; \r\n\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => bool) vips;\r\n  mapping (address => uint256) indexMembers;\r\n  \r\n  struct Member\r\n  {\r\n    address member;\r\n    uint timestamp;\r\n    uint initial_value;\r\n  }\r\n  Member[] public members;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event failingRefund(address indexed _to, uint256 _value);\r\n  event VipMigration(address indexed _vip, uint256 _value);\r\n  event newMember(address indexed _from);\r\n\r\n  // Token parameters\r\n  string public constant name = \"DXF - Decentralized eXperience Friends\";\r\n  string public constant symbol = \"DXF\";\r\n  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n  address public admin;\r\n  address public multisigDXF;\r\n\r\n  modifier onlyAdmin()\r\n  {\r\n    if (msg.sender!=admin) throw;\r\n    _;\r\n  }\r\n\r\n  function DXF_Tokens()\r\n  {\r\n    admin = msg.sender;\r\n    startingDateFunding=now;\r\n    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\r\n    //increment array by 1 for indexes\r\n    members.push(Member(0,0,0));\r\n  }\r\n\r\n\r\n  //empty fallback\r\n  function ()\r\n    {\r\n      throw;\r\n    }\r\n\r\n  //USER FUNCTIONS  \r\n  /// @notice Create tokens when funding is active.\r\n  /// @notice By using this function you accept the terms of DXF\r\n  /// @dev Required state: Funding Active\r\n  /// @dev State transition: -> Funding Success (only if cap reached)\r\n  function acceptTermsAndJoinDXF() payable external \r\n  {\r\n    // refuse if more than 12 months have passed\r\n    if (now>startingDateFunding+365 days) throw;\r\n    // Abort if DXF is not open.\r\n    if (!dxfOpen) throw;\r\n    // verify if the account is not a VIP account\r\n    if (vips[msg.sender]) throw;\r\n    // Do not allow creating less than 10 ether or more than the cap tokens.\r\n    if (msg.value < 10 ether) throw;\r\n    if (msg.value > (tokensCreationCap - totalTokens)) throw;\r\n    // Enforce cap of 10 000 ethers per address / individual\r\n    if (msg.value > (10000 ether - balances[msg.sender])) throw;\r\n    // Register member\r\n    if (balances[msg.sender]==0)\r\n      {\r\n        newMember(msg.sender); //event\r\n\tindexMembers[msg.sender]=members.length;\r\n\tmembers.push(Member(msg.sender,now,msg.value));\r\n      }\r\n    else\r\n      {\r\n\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\r\n      }\r\n    if (members.length>maxNumberMembers) throw;\r\n    //Send the funds to the MultiSig Wallet\r\n    if (multisigDXF==0) throw;\r\n    if (!multisigDXF.send(msg.value)) throw;\r\n    // Assign new tokens to the sender\r\n    uint numTokens = msg.value;\r\n    totalTokens += numTokens;\r\n    // Do not allow creating tokens if we don't leave enough for the VIPs\r\n    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\r\n    balances[msg.sender] += numTokens;\r\n    // Log token creation event\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n\r\n\r\n  //NOT INCLUDED IN LATEST VERSION\r\n  //since we move the funds to multisig\r\n  //refund will be with payback()\r\n  /* /// @notice Get back the ether sent during the funding in case the funding */\r\n  /* /// has not reached the minimum level. */\r\n  /* /// @dev Required state: refund true */\r\n  /* function refund() */\r\n  /* { */\r\n  /*   // Abort if not in refund state */\r\n  /*   if (!refundState) throw; */\r\n  /*   // Not refunded for VIP, we will do a manual refund for them */\r\n  /*   // via the payback function */\r\n  /*   if (vips[msg.sender]) throw; */\r\n  /*   uint value = balances[msg.sender]; */\r\n  /*   if (value == 0) throw; */\r\n  /*   balances[msg.sender] = 0; */\r\n  /*   totalTokens -= value; */\r\n  /*   delete members[indexMembers[msg.sender]]; */\r\n  /*   indexMembers[msg.sender]=0; */\r\n  /*   Refund(msg.sender, value); */\r\n  /*   if (!msg.sender.send(value)) throw; */\r\n  /* } */\r\n\r\n\r\n  //@notice Full Tranfer of DX tokens from sender to '_to'\r\n  //@dev only active if tranfer has been unlocked\r\n  //@param _to address of recipient\r\n  //@param _value amount to tranfer\r\n  //@return success of tranfer ?\r\n  function fullTransfer(address _to) returns (bool)\r\n  {\r\n    // Cancel if tranfer is not allowed\r\n    if (transferLocked) throw;\r\n    if (balances[_to]!=0) throw;\r\n    if (balances[msg.sender]!=0)\r\n      {\r\n\tuint senderBalance = balances[msg.sender];\r\n\tbalances[msg.sender] = 0;\r\n\tbalances[_to]=senderBalance;\r\n\tif (vips[msg.sender])\r\n\t  {\r\n\t    vips[_to]=true;\r\n\t    vips[msg.sender]=false;\r\n\t  }\r\n\tmembers[indexMembers[msg.sender]].member=_to;\r\n\tindexMembers[_to]=indexMembers[msg.sender];\r\n\tindexMembers[msg.sender]=0;\r\n\tTransfer(msg.sender, _to, senderBalance);\r\n\treturn true;\r\n      }\r\n    else\r\n      {\r\n\treturn false;\r\n      }\r\n  }\r\n\r\n\r\n  //ADMIN FUNCTIONS\r\n\r\n\r\n  //@notice called by Admin to manually register migration of previous DO\r\n  //@dev can not be called with a _vip address that is already investor\r\n  //@dev can be called even after the DO is sealed\r\n  //@param _value : balance of VIP at DXDO's creation date\r\n  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\r\n    onlyAdmin\r\n  {\r\n    if (_vip==0) throw;\r\n    if (_vip!=_vip_confirm) throw;\r\n    //don't allow migration to a non empty address\r\n    if (balances[_vip]!=0) throw; \r\n    if (_previous_balance==0) throw;\r\n    uint numberTokens=_previous_balance+(_previous_balance/3);\r\n    totalTokens+=numberTokens;\r\n    //too many tokens created via VIP migration\r\n    if (numberTokens>remainingTokensVIPs) throw;     \r\n    remainingTokensVIPs-=numberTokens;\r\n    balances[_vip]+=numberTokens;\r\n    indexMembers[_vip]=members.length;\r\n    members.push(Member(_vip,now,_previous_balance));\r\n    vips[_vip]=true;\r\n    VipMigration(_vip,_previous_balance);\r\n  }\r\n\r\n\r\n  /// @notice Pay back the ether contributed to the DAO\r\n  function paybackContribution(uint i)\r\n    payable\r\n    onlyAdmin\r\n  {\r\n    address memberRefunded=members[i].member;\r\n    if (memberRefunded==0) throw;\r\n    uint amountTokens=msg.value;\r\n    if (vips[memberRefunded]) \r\n      {\r\n\tamountTokens+=amountTokens/3;\r\n\tremainingTokensVIPs+=amountTokens;\r\n      }\r\n    if (amountTokens>balances[memberRefunded]) throw;\r\n    balances[memberRefunded]-=amountTokens;\r\n    totalTokens-=amountTokens;\r\n    if (balances[memberRefunded]==0) \r\n      {\r\n\tdelete members[i];\r\n\tvips[memberRefunded]=false;\r\n\tindexMembers[memberRefunded]=0;\r\n      }\r\n    if (!memberRefunded.send(msg.value))\r\n      {\r\n        failingRefund(memberRefunded,msg.value);\r\n      }\r\n    Refund(memberRefunded,msg.value);\r\n  }\r\n\r\n\r\n  function changeAdmin(address _admin, address _admin_confirm)\r\n    onlyAdmin\r\n  {\r\n    if (_admin!=_admin_confirm) throw;\r\n    if (_admin==0) throw;\r\n    admin=_admin;\r\n  }\r\n\r\n  //@notice called to seal the DO\r\n  //@dev can not be opened again, marks the end of the fundraising \r\n  //and the recruitment in the DO\r\n  function closeFunding()\r\n    onlyAdmin\r\n  {\r\n    closingDateFunding=now;\r\n    dxfOpen=false;\r\n    //verify if the cap has been reached\r\n    //if not : refund mode\r\n    if (totalTokens<tokensCreationMin)\r\n      {\r\n\trefundState=true;\r\n      }\r\n    else\r\n      {\r\n        //send balance, but should not be necessary.      \r\n\tif(!admin.send(this.balance)) throw;\r\n      }\r\n  }\r\n\r\n  //NOT INCLUDED\r\n  /* function reopenDO() */\r\n  /*   onlyAdmin */\r\n  /* { */\r\n  /*   dxfOpen=true; */\r\n  /*   transferLocked=true; */\r\n  /* } */\r\n\r\n  function allowTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=false;\r\n  }\r\n\r\n  function disableTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=true;\r\n  }\r\n\r\n\r\n  //Constant Functions\r\n  function totalSupply() external constant returns (uint256) \r\n  {\r\n    return totalTokens;\r\n  }\r\n\r\n  function balanceOf(address _owner) external constant returns (uint256) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \r\n  {\r\n    vip=vips[_owner];\r\n    balance_dxf=balances[_owner]/(1 ether);\r\n    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\r\n  }\r\n\r\n\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"refundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accountInformation\",\"outputs\":[{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"balance_dxf\",\"type\":\"uint256\"},{\"name\":\"share_dxf_per_thousands\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_admin_confirm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fullTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationVIPsCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"paybackContribution\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vip\",\"type\":\"address\"},{\"name\":\"_vip_confirm\",\"type\":\"address\"},{\"name\":\"_previous_balance\",\"type\":\"uint256\"}],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"initial_value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dxfOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigDXF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTermsAndJoinDXF\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensVIPs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"failingRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vip\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"VipMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"newMember\",\"type\":\"event\"}]",
        "ContractName": "DXF_Tokens",
        "CompilerVersion": "v0.4.6+commit.2dabbdf0",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x72a68fb6d91ed8dc47b564e088e518c6d4a6ff44",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.6;\r\n\r\ncontract DXF_Tokens{\r\n\r\n  //States\r\n  bool public dxfOpen=true;\r\n  bool public refundState;\r\n  bool public transferLocked=true;\r\n\r\n  uint256 public startingDateFunding;\r\n  uint256 public closingDateFunding;\r\n  //Maximum number of participants\r\n  uint256 public constant maxNumberMembers=5000;\r\n  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\r\n  uint256 public totalTokens;\r\n  uint256 public constant tokensCreationMin = 25000 ether;\r\n  uint256 public constant tokensCreationCap = 75000 ether;\r\n  //Cap of 12500 ethers worth of tokens to be distributed \r\n  //to previous DO members in exchange for their rouleth accounts\r\n  uint256 public remainingTokensVIPs=12500 ether;\r\n  uint256 public constant tokensCreationVIPsCap = 12500 ether; \r\n\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => bool) vips;\r\n  mapping (address => uint256) indexMembers;\r\n  \r\n  struct Member\r\n  {\r\n    address member;\r\n    uint timestamp;\r\n    uint initial_value;\r\n  }\r\n  Member[] public members;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event failingRefund(address indexed _to, uint256 _value);\r\n  event VipMigration(address indexed _vip, uint256 _value);\r\n  event newMember(address indexed _from);\r\n\r\n  // Token parameters\r\n  string public constant name = \"DXF - Decentralized eXperience Friends\";\r\n  string public constant symbol = \"DXF\";\r\n  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n  address public admin;\r\n  address public multisigDXF;\r\n\r\n  modifier onlyAdmin()\r\n  {\r\n    if (msg.sender!=admin) throw;\r\n    _;\r\n  }\r\n\r\n  function DXF_Tokens()\r\n  {\r\n    admin = msg.sender;\r\n    startingDateFunding=now;\r\n    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\r\n    //increment array by 1 for indexes\r\n    members.push(Member(0,0,0));\r\n  }\r\n\r\n\r\n  //empty fallback\r\n  function ()\r\n    {\r\n      throw;\r\n    }\r\n\r\n  //USER FUNCTIONS  \r\n  /// @notice Create tokens when funding is active.\r\n  /// @notice By using this function you accept the terms of DXF\r\n  /// @dev Required state: Funding Active\r\n  /// @dev State transition: -> Funding Success (only if cap reached)\r\n  function acceptTermsAndJoinDXF() payable external \r\n  {\r\n    // refuse if more than 12 months have passed\r\n    if (now>startingDateFunding+365 days) throw;\r\n    // Abort if DXF is not open.\r\n    if (!dxfOpen) throw;\r\n    // verify if the account is not a VIP account\r\n    if (vips[msg.sender]) throw;\r\n    // Do not allow creating less than 10 ether or more than the cap tokens.\r\n    if (msg.value < 10 ether) throw;\r\n    if (msg.value > (tokensCreationCap - totalTokens)) throw;\r\n    // Enforce cap of 10 000 ethers per address / individual\r\n    if (msg.value > (10000 ether - balances[msg.sender])) throw;\r\n    // Register member\r\n    if (balances[msg.sender]==0)\r\n      {\r\n        newMember(msg.sender); //event\r\n\tindexMembers[msg.sender]=members.length;\r\n\tmembers.push(Member(msg.sender,now,msg.value));\r\n      }\r\n    else\r\n      {\r\n\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\r\n      }\r\n    if (members.length>maxNumberMembers) throw;\r\n    //Send the funds to the MultiSig Wallet\r\n    if (multisigDXF==0) throw;\r\n    if (!multisigDXF.send(msg.value)) throw;\r\n    // Assign new tokens to the sender\r\n    uint numTokens = msg.value;\r\n    totalTokens += numTokens;\r\n    // Do not allow creating tokens if we don't leave enough for the VIPs\r\n    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\r\n    balances[msg.sender] += numTokens;\r\n    // Log token creation event\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n\r\n\r\n  //NOT INCLUDED IN LATEST VERSION\r\n  //since we move the funds to multisig\r\n  //refund will be with payback()\r\n  /* /// @notice Get back the ether sent during the funding in case the funding */\r\n  /* /// has not reached the minimum level. */\r\n  /* /// @dev Required state: refund true */\r\n  /* function refund() */\r\n  /* { */\r\n  /*   // Abort if not in refund state */\r\n  /*   if (!refundState) throw; */\r\n  /*   // Not refunded for VIP, we will do a manual refund for them */\r\n  /*   // via the payback function */\r\n  /*   if (vips[msg.sender]) throw; */\r\n  /*   uint value = balances[msg.sender]; */\r\n  /*   if (value == 0) throw; */\r\n  /*   balances[msg.sender] = 0; */\r\n  /*   totalTokens -= value; */\r\n  /*   delete members[indexMembers[msg.sender]]; */\r\n  /*   indexMembers[msg.sender]=0; */\r\n  /*   Refund(msg.sender, value); */\r\n  /*   if (!msg.sender.send(value)) throw; */\r\n  /* } */\r\n\r\n\r\n  //@notice Full Tranfer of DX tokens from sender to '_to'\r\n  //@dev only active if tranfer has been unlocked\r\n  //@param _to address of recipient\r\n  //@param _value amount to tranfer\r\n  //@return success of tranfer ?\r\n  function fullTransfer(address _to) returns (bool)\r\n  {\r\n    // Cancel if tranfer is not allowed\r\n    if (transferLocked) throw;\r\n    if (balances[_to]!=0) throw;\r\n    if (balances[msg.sender]!=0)\r\n      {\r\n\tuint senderBalance = balances[msg.sender];\r\n\tbalances[msg.sender] = 0;\r\n\tbalances[_to]=senderBalance;\r\n\tif (vips[msg.sender])\r\n\t  {\r\n\t    vips[_to]=true;\r\n\t    vips[msg.sender]=false;\r\n\t  }\r\n\tmembers[indexMembers[msg.sender]].member=_to;\r\n\tindexMembers[_to]=indexMembers[msg.sender];\r\n\tindexMembers[msg.sender]=0;\r\n\tTransfer(msg.sender, _to, senderBalance);\r\n\treturn true;\r\n      }\r\n    else\r\n      {\r\n\treturn false;\r\n      }\r\n  }\r\n\r\n\r\n  //ADMIN FUNCTIONS\r\n\r\n\r\n  //@notice called by Admin to manually register migration of previous DO\r\n  //@dev can not be called with a _vip address that is already investor\r\n  //@dev can be called even after the DO is sealed\r\n  //@param _value : balance of VIP at DXDO's creation date\r\n  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\r\n    onlyAdmin\r\n  {\r\n    if (_vip==0) throw;\r\n    if (_vip!=_vip_confirm) throw;\r\n    //don't allow migration to a non empty address\r\n    if (balances[_vip]!=0) throw; \r\n    if (_previous_balance==0) throw;\r\n    uint numberTokens=_previous_balance+(_previous_balance/3);\r\n    totalTokens+=numberTokens;\r\n    //too many tokens created via VIP migration\r\n    if (numberTokens>remainingTokensVIPs) throw;     \r\n    remainingTokensVIPs-=numberTokens;\r\n    balances[_vip]+=numberTokens;\r\n    indexMembers[_vip]=members.length;\r\n    members.push(Member(_vip,now,_previous_balance));\r\n    vips[_vip]=true;\r\n    VipMigration(_vip,_previous_balance);\r\n  }\r\n\r\n\r\n  /// @notice Pay back the ether contributed to the DAO\r\n  function paybackContribution(uint i)\r\n    payable\r\n    onlyAdmin\r\n  {\r\n    address memberRefunded=members[i].member;\r\n    if (memberRefunded==0) throw;\r\n    uint amountTokens=msg.value;\r\n    if (vips[memberRefunded]) \r\n      {\r\n\tamountTokens+=amountTokens/3;\r\n\tremainingTokensVIPs+=amountTokens;\r\n      }\r\n    if (amountTokens>balances[memberRefunded]) throw;\r\n    balances[memberRefunded]-=amountTokens;\r\n    totalTokens-=amountTokens;\r\n    if (balances[memberRefunded]==0) \r\n      {\r\n\tdelete members[i];\r\n\tvips[memberRefunded]=false;\r\n\tindexMembers[memberRefunded]=0;\r\n      }\r\n    if (!memberRefunded.send(msg.value))\r\n      {\r\n        failingRefund(memberRefunded,msg.value);\r\n      }\r\n    Refund(memberRefunded,msg.value);\r\n  }\r\n\r\n\r\n  function changeAdmin(address _admin, address _admin_confirm)\r\n    onlyAdmin\r\n  {\r\n    if (_admin!=_admin_confirm) throw;\r\n    if (_admin==0) throw;\r\n    admin=_admin;\r\n  }\r\n\r\n  //@notice called to seal the DO\r\n  //@dev can not be opened again, marks the end of the fundraising \r\n  //and the recruitment in the DO\r\n  function closeFunding()\r\n    onlyAdmin\r\n  {\r\n    closingDateFunding=now;\r\n    dxfOpen=false;\r\n    //verify if the cap has been reached\r\n    //if not : refund mode\r\n    if (totalTokens<tokensCreationMin)\r\n      {\r\n\trefundState=true;\r\n      }\r\n    else\r\n      {\r\n        //send balance, but should not be necessary.      \r\n\tif(!admin.send(this.balance)) throw;\r\n      }\r\n  }\r\n\r\n  //NOT INCLUDED\r\n  /* function reopenDO() */\r\n  /*   onlyAdmin */\r\n  /* { */\r\n  /*   dxfOpen=true; */\r\n  /*   transferLocked=true; */\r\n  /* } */\r\n\r\n  function allowTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=false;\r\n  }\r\n\r\n  function disableTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=true;\r\n  }\r\n\r\n\r\n  //Constant Functions\r\n  function totalSupply() external constant returns (uint256) \r\n  {\r\n    return totalTokens;\r\n  }\r\n\r\n  function balanceOf(address _owner) external constant returns (uint256) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \r\n  {\r\n    vip=vips[_owner];\r\n    balance_dxf=balances[_owner]/(1 ether);\r\n    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\r\n  }\r\n\r\n\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"refundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accountInformation\",\"outputs\":[{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"balance_dxf\",\"type\":\"uint256\"},{\"name\":\"share_dxf_per_thousands\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_admin_confirm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fullTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationVIPsCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"paybackContribution\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vip\",\"type\":\"address\"},{\"name\":\"_vip_confirm\",\"type\":\"address\"},{\"name\":\"_previous_balance\",\"type\":\"uint256\"}],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"initial_value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dxfOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigDXF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTermsAndJoinDXF\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensVIPs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"failingRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vip\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"VipMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"newMember\",\"type\":\"event\"}]",
        "ContractName": "DXF_Tokens",
        "CompilerVersion": "v0.4.6+commit.2dabbdf0",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x23a32f84d9a6d163593a49f052d5039c05469da6",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.6;\r\n\r\ncontract DXF_Tokens{\r\n\r\n  //States\r\n  bool public dxfOpen=true;\r\n  bool public refundState;\r\n  bool public transferLocked=true;\r\n\r\n  uint256 public startingDateFunding;\r\n  uint256 public closingDateFunding;\r\n  //Maximum number of participants\r\n  uint256 public constant maxNumberMembers=5000;\r\n  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\r\n  uint256 public totalTokens;\r\n  uint256 public constant tokensCreationMin = 25000 ether;\r\n  uint256 public constant tokensCreationCap = 75000 ether;\r\n  //Cap of 12500 ethers worth of tokens to be distributed \r\n  //to previous DO members in exchange for their rouleth accounts\r\n  uint256 public remainingTokensVIPs=12500 ether;\r\n  uint256 public constant tokensCreationVIPsCap = 12500 ether; \r\n\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => bool) vips;\r\n  mapping (address => uint256) indexMembers;\r\n  \r\n  struct Member\r\n  {\r\n    address member;\r\n    uint timestamp;\r\n    uint initial_value;\r\n  }\r\n  Member[] public members;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event failingRefund(address indexed _to, uint256 _value);\r\n  event VipMigration(address indexed _vip, uint256 _value);\r\n  event newMember(address indexed _from);\r\n\r\n  // Token parameters\r\n  string public constant name = \"DXF - Decentralized eXperience Friends\";\r\n  string public constant symbol = \"DXF\";\r\n  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n  address public admin;\r\n  address public multisigDXF;\r\n\r\n  modifier onlyAdmin()\r\n  {\r\n    if (msg.sender!=admin) throw;\r\n    _;\r\n  }\r\n\r\n  function DXF_Tokens()\r\n  {\r\n    admin = msg.sender;\r\n    startingDateFunding=now;\r\n    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\r\n    //increment array by 1 for indexes\r\n    members.push(Member(0,0,0));\r\n  }\r\n\r\n\r\n  //empty fallback\r\n  function ()\r\n    {\r\n      throw;\r\n    }\r\n\r\n  //USER FUNCTIONS  \r\n  /// @notice Create tokens when funding is active.\r\n  /// @notice By using this function you accept the terms of DXF\r\n  /// @dev Required state: Funding Active\r\n  /// @dev State transition: -> Funding Success (only if cap reached)\r\n  function acceptTermsAndJoinDXF() payable external \r\n  {\r\n    // refuse if more than 12 months have passed\r\n    if (now>startingDateFunding+365 days) throw;\r\n    // Abort if DXF is not open.\r\n    if (!dxfOpen) throw;\r\n    // verify if the account is not a VIP account\r\n    if (vips[msg.sender]) throw;\r\n    // Do not allow creating less than 10 ether or more than the cap tokens.\r\n    if (msg.value < 10 ether) throw;\r\n    if (msg.value > (tokensCreationCap - totalTokens)) throw;\r\n    // Enforce cap of 10 000 ethers per address / individual\r\n    if (msg.value > (10000 ether - balances[msg.sender])) throw;\r\n    // Register member\r\n    if (balances[msg.sender]==0)\r\n      {\r\n        newMember(msg.sender); //event\r\n\tindexMembers[msg.sender]=members.length;\r\n\tmembers.push(Member(msg.sender,now,msg.value));\r\n      }\r\n    else\r\n      {\r\n\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\r\n      }\r\n    if (members.length>maxNumberMembers) throw;\r\n    //Send the funds to the MultiSig Wallet\r\n    if (multisigDXF==0) throw;\r\n    if (!multisigDXF.send(msg.value)) throw;\r\n    // Assign new tokens to the sender\r\n    uint numTokens = msg.value;\r\n    totalTokens += numTokens;\r\n    // Do not allow creating tokens if we don't leave enough for the VIPs\r\n    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\r\n    balances[msg.sender] += numTokens;\r\n    // Log token creation event\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n\r\n\r\n  //NOT INCLUDED IN LATEST VERSION\r\n  //since we move the funds to multisig\r\n  //refund will be with payback()\r\n  /* /// @notice Get back the ether sent during the funding in case the funding */\r\n  /* /// has not reached the minimum level. */\r\n  /* /// @dev Required state: refund true */\r\n  /* function refund() */\r\n  /* { */\r\n  /*   // Abort if not in refund state */\r\n  /*   if (!refundState) throw; */\r\n  /*   // Not refunded for VIP, we will do a manual refund for them */\r\n  /*   // via the payback function */\r\n  /*   if (vips[msg.sender]) throw; */\r\n  /*   uint value = balances[msg.sender]; */\r\n  /*   if (value == 0) throw; */\r\n  /*   balances[msg.sender] = 0; */\r\n  /*   totalTokens -= value; */\r\n  /*   delete members[indexMembers[msg.sender]]; */\r\n  /*   indexMembers[msg.sender]=0; */\r\n  /*   Refund(msg.sender, value); */\r\n  /*   if (!msg.sender.send(value)) throw; */\r\n  /* } */\r\n\r\n\r\n  //@notice Full Tranfer of DX tokens from sender to '_to'\r\n  //@dev only active if tranfer has been unlocked\r\n  //@param _to address of recipient\r\n  //@param _value amount to tranfer\r\n  //@return success of tranfer ?\r\n  function fullTransfer(address _to) returns (bool)\r\n  {\r\n    // Cancel if tranfer is not allowed\r\n    if (transferLocked) throw;\r\n    if (balances[_to]!=0) throw;\r\n    if (balances[msg.sender]!=0)\r\n      {\r\n\tuint senderBalance = balances[msg.sender];\r\n\tbalances[msg.sender] = 0;\r\n\tbalances[_to]=senderBalance;\r\n\tif (vips[msg.sender])\r\n\t  {\r\n\t    vips[_to]=true;\r\n\t    vips[msg.sender]=false;\r\n\t  }\r\n\tmembers[indexMembers[msg.sender]].member=_to;\r\n\tindexMembers[_to]=indexMembers[msg.sender];\r\n\tindexMembers[msg.sender]=0;\r\n\tTransfer(msg.sender, _to, senderBalance);\r\n\treturn true;\r\n      }\r\n    else\r\n      {\r\n\treturn false;\r\n      }\r\n  }\r\n\r\n\r\n  //ADMIN FUNCTIONS\r\n\r\n\r\n  //@notice called by Admin to manually register migration of previous DO\r\n  //@dev can not be called with a _vip address that is already investor\r\n  //@dev can be called even after the DO is sealed\r\n  //@param _value : balance of VIP at DXDO's creation date\r\n  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\r\n    onlyAdmin\r\n  {\r\n    if (_vip==0) throw;\r\n    if (_vip!=_vip_confirm) throw;\r\n    //don't allow migration to a non empty address\r\n    if (balances[_vip]!=0) throw; \r\n    if (_previous_balance==0) throw;\r\n    uint numberTokens=_previous_balance+(_previous_balance/3);\r\n    totalTokens+=numberTokens;\r\n    //too many tokens created via VIP migration\r\n    if (numberTokens>remainingTokensVIPs) throw;     \r\n    remainingTokensVIPs-=numberTokens;\r\n    balances[_vip]+=numberTokens;\r\n    indexMembers[_vip]=members.length;\r\n    members.push(Member(_vip,now,_previous_balance));\r\n    vips[_vip]=true;\r\n    VipMigration(_vip,_previous_balance);\r\n  }\r\n\r\n\r\n  /// @notice Pay back the ether contributed to the DAO\r\n  function paybackContribution(uint i)\r\n    payable\r\n    onlyAdmin\r\n  {\r\n    address memberRefunded=members[i].member;\r\n    if (memberRefunded==0) throw;\r\n    uint amountTokens=msg.value;\r\n    if (vips[memberRefunded]) \r\n      {\r\n\tamountTokens+=amountTokens/3;\r\n\tremainingTokensVIPs+=amountTokens;\r\n      }\r\n    if (amountTokens>balances[memberRefunded]) throw;\r\n    balances[memberRefunded]-=amountTokens;\r\n    totalTokens-=amountTokens;\r\n    if (balances[memberRefunded]==0) \r\n      {\r\n\tdelete members[i];\r\n\tvips[memberRefunded]=false;\r\n\tindexMembers[memberRefunded]=0;\r\n      }\r\n    if (!memberRefunded.send(msg.value))\r\n      {\r\n        failingRefund(memberRefunded,msg.value);\r\n      }\r\n    Refund(memberRefunded,msg.value);\r\n  }\r\n\r\n\r\n  function changeAdmin(address _admin, address _admin_confirm)\r\n    onlyAdmin\r\n  {\r\n    if (_admin!=_admin_confirm) throw;\r\n    if (_admin==0) throw;\r\n    admin=_admin;\r\n  }\r\n\r\n  //@notice called to seal the DO\r\n  //@dev can not be opened again, marks the end of the fundraising \r\n  //and the recruitment in the DO\r\n  function closeFunding()\r\n    onlyAdmin\r\n  {\r\n    closingDateFunding=now;\r\n    dxfOpen=false;\r\n    //verify if the cap has been reached\r\n    //if not : refund mode\r\n    if (totalTokens<tokensCreationMin)\r\n      {\r\n\trefundState=true;\r\n      }\r\n    else\r\n      {\r\n        //send balance, but should not be necessary.      \r\n\tif(!admin.send(this.balance)) throw;\r\n      }\r\n  }\r\n\r\n  //NOT INCLUDED\r\n  /* function reopenDO() */\r\n  /*   onlyAdmin */\r\n  /* { */\r\n  /*   dxfOpen=true; */\r\n  /*   transferLocked=true; */\r\n  /* } */\r\n\r\n  function allowTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=false;\r\n  }\r\n\r\n  function disableTransfers()\r\n    onlyAdmin\r\n  {\r\n    transferLocked=true;\r\n  }\r\n\r\n\r\n  //Constant Functions\r\n  function totalSupply() external constant returns (uint256) \r\n  {\r\n    return totalTokens;\r\n  }\r\n\r\n  function balanceOf(address _owner) external constant returns (uint256) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \r\n  {\r\n    vip=vips[_owner];\r\n    balance_dxf=balances[_owner]/(1 ether);\r\n    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\r\n  }\r\n\r\n\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"refundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accountInformation\",\"outputs\":[{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"balance_dxf\",\"type\":\"uint256\"},{\"name\":\"share_dxf_per_thousands\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_admin_confirm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fullTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationVIPsCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"paybackContribution\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vip\",\"type\":\"address\"},{\"name\":\"_vip_confirm\",\"type\":\"address\"},{\"name\":\"_previous_balance\",\"type\":\"uint256\"}],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"initial_value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dxfOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigDXF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingDateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTermsAndJoinDXF\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensVIPs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"failingRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vip\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"VipMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"newMember\",\"type\":\"event\"}]",
        "ContractName": "DXF_Tokens",
        "CompilerVersion": "v0.4.6+commit.2dabbdf0",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x43033b3aa89a988ba1b23ef8b25eb980426cc3e1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd18293d1cc41b239fe7ed95f9e916ee9363f2da0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa014638fd7fe57a42ec48168fc25ed8df6766680",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc112115dd53c5f74a11cf85f45960519d8557869",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe197a9f2c8523691effeedd22fb3c4bfa1c5c7bb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x369f9bf12a2ad5b3df9c7dd75cff4b46f5c34fae",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x976036d0c554e733b903c8f5145c05483c7fec04",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2d378f7ede1972c90aae239d2d56027be3efc3a5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xda45155c8a3e80faa8124fd01e7c4ddc86988a99",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9ee61197f113e56298dd1822fde608572f75a640",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1168d2d8a16369d64729e6ff8f567d4de3a45b3d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb419f38a92556f75cde7baa52c44f3e623e4215f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3603dfc9615521a5e32acd7ccd15857befb86c66",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x63532de8947703b9fcc5890e9cb991ac51ed97e6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf3ce232db4b1568ecbeda1ff377476935681b21d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc7199e9f4c4970a40a0789e7c7975108bee18deb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2900fee827d3b8dc4e5e397edcfb03ff92b41222",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x72242152662dbde1c92ed4b928544c27458ddc8b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0b4e49be55b03cc71ace331bf91974613ee14d71",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xac6ca378272baaba81eab099f56ce0307700e424",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb961db7965267b3446f5390971078b34c9386974",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3fda5300d189bfa38c375ab2cddadafdec0ebb66",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbb7e2663b0cf02b4299013301970ccc406c70480",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc0eeee66ea30b31ead52a38ff2ae1ee5c5ba69a4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5aab35f8086d085fd94b97677467645aa361a43e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5357b8399682f6f4c3b9a24052044741d3c82b33",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6be5651e3a7921ed694ec35f697c888cdcbd0898",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb1966753dd815d5ab10e33a355db958577d34c4c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x431036c25ac7edb45dd5f1b47d480faa1df5f988",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x423a88cedc6d32b9856240183dc25db2e0970ef5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe3e74d935ca553a8dc9e03de7e6912bf440f7fe3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x957b31ad60e7ed425c5468f38e8b2906f44e40cc",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd81f18cb53793fc5998cd489adfeb323c33b9956",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9f6bfc6b89fb4c555d32d9cdeb3559b256ee855f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x377e04a8c204e12301adde358ea7b6c2f7ac53cd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x427b79d9b17e389659cdfe933a15e2fb3b27a9b1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9442d0a13e32cef0afd370285a67987bf187d652",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8fadb4814a9914f08ae303f9a89e46d366ea0ebc",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbb4a2c780a4b9b6f5f77da8398bbf91c2106736a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x14c5234bad12c83f5260041bbec57d2430d45980",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x511addf7dcdc2e27fb2b4be231b6ee06de278887",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9c7014631effe8de2fd679a60b2c44288e3f6e6a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x78ae101d7e5d3ea9367bb4e9f71ea09f1d6dee34",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb006f0754014bf84c1510976f0ac301c26d3d008",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2f2b5578a02b826d9b8192efce497318e6b9abe6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8337f436d739339be60fd49b8e451d86efc172de",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x128f4deb78e9ca94c5a7ec8525cbf6a887ff2d03",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbb99ac60a5a8901082af24ad763fcf75988fd155",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x395137c5191e0b15328bcfa71ecdad8fdc023f3e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4c733eb96e7610ac9f5fadac069b0380ca7f107c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x75fbaa1fdefac8f8f2828d007c259f102fed4e81",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfb34065a0b1603bdc5c6e5463a6d9529164d9745",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf94bb3d4746bf4928af188c2c37cf9df72ce9169",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3086106acaf5d14e836582049f9d947f9253e852",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7fbf2fb228d7c7c73c04113a806c6f3e3bbab6a3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd08a01bb326bc4684bd311af4fb64fcbae4a53a2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6b35481b7c41132460bd62000d1bda75cde5d20b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5e9e964965ae660af6228a950bbde755c857eede",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe54c7abad2eadc6549112a0289be11949bf98478",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcf07aad2db55ed49cebd41def68ce0583ece89e5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2f8e4ea9b27a3c045b774a2441402f6c322ae954",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf603fe854332127c9354b11ac965166a27cc56b3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xeed1bb645cd8d0b5ee7aa165f08d4dd2e1c62128",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9f435fe66802a9aeef1daebc71c47b209eb0c949",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x507a58c7e74e369da118d63f613524d0f17a9c8f",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9f22c0409cf707a9d66882bc687c5f85a5b72105",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb07fb0baccc3a92d230bae89aeaae41b44aef5ee",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1f28f707b3d63fe14ef248361d8596a93072e048",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9cbff64255094129800c6ea6d1f575e0c7b75daf",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x037cbdd7f9fb84688909cbe0f6dcd27ac9235b82",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbc4c568dfeffc3781e2e13faba53fdd524ec2aea",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x00872c8630192c3ba8d9de22377a386e6611682c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2e671055ee5fec20392a5ea7113dd81903c8e9c6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x97dba7d6812cb6c1eaa3db02286682d12185e9f0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf1a6a4db96b46693de8c0d47b3e10944853fe4b1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xea0e8102b35c4e461133da5b7ffb9410f90217b2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xee0d2a158a610f9beb8211888c03decf0ea6548a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x67345a25e07a87c5e7bb35bad12cae112a542296",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x881556346d42a50093ea47a84cc64a645417ce41",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd00d10a02828b19da34424a137812e87f12bb3c5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x314ca4444bb47ef5b2c71d1f0da646d7e68de53e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x18d7b9add548eede0310e07b8a705e7fec34da56",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfaa05cbf10a18bc4ccd60327dc074e9215681081",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe65f1717ec961a58f90117a57ee64c5c60c50246",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x15c8024442a5ce2408de70c62e3c14b5b359e825",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0f88494df0374e27a7db7f5fe8b667e8c494093b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc4ae67448939e1437256e8423d4ab7b578055b92",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7d003ae2952b54ab290f9a1f7c1cd91b8f705e17",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe2ad4048ed3db4e30c7dcf5eb6d5f1eef40d7929",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3c385ea7e2150ddb41de08fd6cfd0a163393f47b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4145402780bffa3d0cc1b42d8c091cfedbc884ff",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa7dbad7742381ba7cc70ff349dae97a90b8279f1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xccd93e2daa5485b506fb1f3d42c073f811c89c8f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xde32a695efb7d716b2064a2c4808d706575e1602",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x56fff146d642afad6ae40efae77d21ece2b9ff95",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x41431c91fdb06d820d853488d27d761b8e0c665d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x349891e9e586530d24a8dedc8d19f134e90a6e8c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2f92fa31deb7eea2028e77337c99277864d64c17",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc01cbf9ea107a560155ef2079221bc20d69f3007",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4ed593551aa38550249869fcda8520b82a126e60",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7573c8f369a657c4e0c2fa8eebf00d96693b6f79",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x620bef153465ca2775a171b1de3d20c8929cca53",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x952feaadacb21e8e185bb0fe5f02d7cf5d403aef",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x15c1c2ebd1bb4ce7b0500c7f5e2c07a52f7510ff",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf59e190ebc4266c5fca6012f3fba96dd336e5657",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc2fb352ff058373ef676e2384c4a2b1bef11e774",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd01e9ea7ccd572b8f0bafc432cc13e0e248a600f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbcbe9eea8085daf4800e58b485dc3f28b9d18225",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x640b76ce4a8f31760d099d133b6d9e2c97b96095",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1bdf7f918eb44f2244d77da1867ca9dc8c4f3c4b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc4c6832d91489b56024d11932dfdb3eb36de8caa",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf7a96e00902a680d04122e6a93494527424d6986",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd612f8ff3433a57c531b3e2f3ce523f314219f79",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x697ba16aee22ea5816b8d0c97d351e664f80cb3f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3e4731abdb9ce0a42ea2dadd9001356645f0ee5f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8f96a7779ecb9fca505440246ee1054d2e198282",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa2afdfaece8234132d24c64b3f29dd1bbf7daea2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc4a6f90e67ff677f1ebab349ba8131dc624d3ce0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xaa9d1186c7e62c9838662530739f90f29c031f2b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x16b87cb238a4c8fc624cdaff82b266d5fd47a618",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x892b3538da435d4b4f67d01f22621c382a63d861",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x194dba32108c813b721bd08068cc01da3fce1d51",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x406499b0faeea703b8803b903b7e2d9f7ff8cf5e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd7aaa54ea2d54aa57e002dedbe02a9ae986a715a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x94fc1c35d1b9ebe91bb12e575aa48f68905565c9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd4fa87d4815917680500fd805db1d64cf09a6371",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xff07c9f5fcde6da9b8bcf86197d5922ed2c57f9a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5471fbd23bb5dc455042bce6d53346cd8a3ca7e6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x73d3472410e2e1b48828a40ad6c8ec8efb9743db",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8c250eda6032d141cf3d7191f4b3931c392248a4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x84c1683949e4f25fcfc94cce94326a6da45dc240",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc467c0d6c5c203c20296c7027794a60c0262ef50",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdd550493f507568a09febe7aa54eaffabb49cc73",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1cfee5ed863f29a06e1794e2a38dcc740e3ce5e7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe017b3366a340eeb7b1e876feee0ca2a32b5d2b1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8328cd60402132eae0d4ae1b5893bb571596ce2c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x85e75b0ff4bf0a555cb9166a2c67b6439d3ceb30",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe2b5c8af40167afef3df4daae5e05b70cdc5b4a3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xff821e51150dea3ca4d201d0df4e568dc9e03239",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x609b4cf4b8dc417280601c1eecf52b4fec33b7d0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb00e9048dfaf98d27dd01d5dd3b59522ddad02ef",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf50c498618e2184415649b5cb2e559f27197cfa0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3e72a25756862bdefc27ae6d64de3115d19b98d4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8087c01a5a779e8540d1360c44808f7e32fc87be",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9b078eab6275a15f0ea03be89a4aad05fef94628",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x04284523edd0623b2a2184854b4a19df8e48dd91",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1dc39a693ff32d0c8edd427b3df106e8673f370f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfe58c814eca274d93a6e34b3d6d2d81cb779202f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe0ca30f76535a04fe1bc63270aad5e86d4309079",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc32e2da8bf449bb2c4f2e0a6757de575fa434d43",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x999abed1d47410bff72cd53635f16ff368e592b1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf99188a35ac1c46651fb6695c1c57938811f004c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbe6df430a1d20a43d0c265e8ee1aa746e7454280",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb321591a6f44e21cb4f8f51ef61e937b4f1a78bf",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc86be9745b33f51f863bdfcb2d9961d49b6f0ff4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x680504eb1378783af5bd9dfd11a37ed04b2f0a0d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe9736a18ca946fda8c0ca241f80bfa2b88d7df4d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5e2f714665aa96674f869bd34a8f7d9a5ea6857c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x07b20c21da8d599fd69b1ac29526b3d39c81aadc",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0b8a2622121e6d66881654be9c40691b404485fc",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd1cfb9913c309a53d6bd826f7faadb7c85f8fc93",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9793e75ade0d088318249a4f220d7ad716ddda95",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xeae35918da8e222efe86272964d37bea17db4e72",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3f561a0c85a3ea955492ca0137f4fa580ceac135",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2fbc262d5eac552ff390dd1685812df4e6d94800",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4c97341dea59aff36f6439ca332182eb05307f27",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x880cb32dec8d2bee8ac318ee3f243251446c20e5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x76fa3c67a344c9dbf8c6307c8cc3d5dd958a460a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x25e460584fbaf086e051912f33cd1b9bf56ddffa",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x42a8e3766128f804a206726843c80f828155ce1b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3fb76c2ca6258048814f963d47f3711ab607816c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xed3a1a88fb7ae1ccff819250d006427f0fecb618",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x12d69f8f8195629e8024ac3ff13c72101447f9e3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8a2b53dce5a7b251b1d49a0a85a71a1bd2fad057",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc7ff23502e554201d37136be4294d9b9cdc10c10",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe1675b4f8d42fe0f9a9c393cb0723a7af35fb4f9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xeb005bf69690782d88c02bed5da374146187f062",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6267083563d8987f9936a845017d366c8509d99e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7d2d3da04ea47033356f82e8084570a3ee60b49a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7d6ffb79e6109bd4c30df0914c6e034a91c70800",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2a724c0b7ce06a476b8981c2af384dd89a5747c0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf608f9c8a4559d24b48e0106d8cb136f2e1d99e0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x37226ef114bfaa03e4f0b0b38e1f4d8a8955c805",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1992094310662f5b1d3353bc781f1878c4e93321",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf1eb8b0dc95f9975a9a31d40f708abd95b15efe7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x682105f642579c19b1037764b94b2d6329b76f17",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcb27bf2ed06def886e2d024c65ec13efeac0da27",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb3e0924ce5440ef054a2896634f338ae02cd58bd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9112d47b04b27dbae7e969a21e946627ed57b47a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xba804663e600845d5ba9c60ef72b0cb3e33da640",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4e452f688179d05a994123e416233a083732e6c0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf579ccb8c138d0dce2583fd1ca6a8e15cb641eb3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdca84f2384194cefe0d2e5a054b7ac11e279c47b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x71037061475dbf3ec4c2d560a5e0dc1aba055eba",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3c3fd68a2dff6ce5e1db58ec0948c340f6077e9f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x28001e0390be5d73530cadd065f69fe3b96f9400",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfe0e469025237b65948efd983821d75d28186884",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x89f51e6c6a5437614edb8ff64a48362411566f1e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdf4c3476180677da5898fd36c6ad33df6892cb16",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x412d749b11df4820a86607abfa0c91f518c1fa68",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5eaba72622c7881a15aaf099c6e20d2cb99874ce",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa0e053e382264ca4a13578b05a256236e921c581",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc155e54801d7fd4410bd26597f3ed6a07101382d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x888ff29590754de8cdd2fba86e3a7365c9d8f6c8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd4299abb38d76ef9f9abc9d3c139fecdfdc2022c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf7149c9266d10e85abe3ec4e5a9a4d22fd3cdc22",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcc6fbcf12e0c4f5e168cbded2cdf462751032ae8",
    "result": [
      {
        "SourceCode": "contract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*\r\nThis implements ONLY the standard functions and NOTHING else.\r\nFor a token like you would want to deploy in something like Mist, see HumanStandardToken.sol.\r\n\r\nIf you deploy this, you won't have anything useful.\r\n\r\nImplements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\n.*/\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n/*\r\nThis Token Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans.\r\n\r\nIn other words. This is intended for deployment in something like a Token Factory or Mist wallet, and then used by humans.\r\nImagine coins, currencies, shares, voting weight, etc.\r\nMachine-based, rapid creation of many tokens would not necessarily need these extra features or will be minted in other manners.\r\n\r\n1) Initial Finite Supply (upon creation one specifies how much is minted).\r\n2) In the absence of a token registry: Optional Decimal, Symbol & Name.\r\n3) Optional approveAndCall() functionality to notify a contract if an approval() has occurred.\r\n\r\n.*/\r\n\r\ncontract HumanStandardToken is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    function HumanStandardToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        ) {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialAmount\",\"type\":\"uint256\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_decimalUnits\",\"type\":\"uint8\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]",
        "ContractName": "HumanStandardToken",
        "CompilerVersion": "v0.3.5+commit.5f97274",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "000000000000000000000000000000000000000000000000000000094443ce000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000976657468776f726c64000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000047665746800000000000000000000000000000000000000000000000000000000",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf7323cf0f8fbb2de6f20ddb5dbe788377292b006",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xec796814fc3f3c79575773da83a53a334f9c46df",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract customIcoToken{\r\n    using SafeMath for uint256;\r\n\r\n    /* Events */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateToken(address indexed _to, uint256 _value);\r\n\r\n    // metadata\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals;\r\n\r\n    // contracts\r\n    address public ethFundDeposit;      // deposit address for ETH\r\n    address public tokenFundDeposit;\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public tokenFund;\r\n    uint256 public tokenExchangeRate;\r\n    uint256 public tokenCreationCap;\r\n    uint256 public tokenCreationMin;\r\n\r\n    /* Storage */\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    /* Getters */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /* Methods */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n  }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    /* Crowdsale methods */\r\n\r\n    /// @dev Accepts ether and creates new tokens.\r\n    function createTokens() payable external {\r\n      require (isFinalized == false);\r\n      require(block.number > fundingStartBlock);\r\n      require(block.number < fundingEndBlock);\r\n      require(msg.value > 0);\r\n\r\n      uint256 tokens = msg.value.mul(tokenExchangeRate);\r\n      uint256 checkedSupply = totalSupply.add(tokens);\r\n\r\n      // return money if something goes wrong\r\n      require(tokenCreationCap >= checkedSupply); // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      emit CreateToken(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    /// @dev Ends the funding period and sends the ETH home\r\n    function finalize() external {\r\n      require(isFinalized == false);\r\n      require(msg.sender == ethFundDeposit);\r\n      require(totalSupply > tokenCreationMin); // have to sell minimum to move to operational\r\n      require(block.number > fundingEndBlock || totalSupply == tokenCreationCap);\r\n      // move to operational\r\n      isFinalized = true;\r\n      assert(ethFundDeposit.send(address(this).balance)); // send the eth\r\n    }\r\n\r\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n    function refund() external {\r\n      require(isFinalized == false);                       // prevents refund if operational\r\n      require(block.number > fundingEndBlock); // prevents refund until sale period is over\r\n      require(totalSupply < tokenCreationMin); // no refunds if we sold enough\r\n      require(msg.sender != tokenFundDeposit);    // team not entitled to a refund\r\n      uint256 tokenVal = balances[msg.sender];\r\n      require(tokenVal > 0);\r\n      balances[msg.sender] = 0;\r\n      totalSupply = totalSupply.sub(tokenVal); // extra safe\r\n      uint256 ethVal = tokenVal / tokenExchangeRate; // should be safe; previous throws covers edges\r\n      emit LogRefund(msg.sender, ethVal); // log it\r\n      assert(msg.sender.send(ethVal)); // if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n    constructor(\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals,\r\n        address _ethFundDeposit,\r\n        address _tokenFundDeposit,\r\n        uint256 _tokenFund,\r\n        uint256 _tokenExchangeRate,\r\n        uint256 _tokenCreationCap,\r\n        uint256 _tokenCreationMin,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock) public\r\n    {\r\n      name = _name;\r\n      symbol = _symbol;\r\n      decimals = _decimals;\r\n      isFinalized = false;                   //controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      tokenFundDeposit = _tokenFundDeposit;\r\n      tokenFund = _tokenFund*10**decimals;\r\n      tokenExchangeRate = _tokenExchangeRate;\r\n      tokenCreationCap = _tokenCreationCap*10**decimals;\r\n      tokenCreationMin = _tokenCreationMin*10**decimals;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = tokenFund;\r\n      balances[tokenFundDeposit] = tokenFund;\r\n      emit CreateToken(tokenFundDeposit, tokenFund);\r\n    }\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_ethFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFund\",\"type\":\"uint256\"},{\"name\":\"_tokenExchangeRate\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationCap\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationMin\",\"type\":\"uint256\"},{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_fundingEndBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CreateToken\",\"type\":\"event\"}]",
        "ContractName": "customIcoToken",
        "CompilerVersion": "v0.4.24+commit.e67f0147",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000000000000000000000000000000000174876e80000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000022ecb25c0000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060ee74000000000000000000000000000000000000000000000000000000000000000e435245454b434f494e2043524b43000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000443524b4300000000000000000000000000000000000000000000000000000000",
        "Library": "",
        "SwarmSource": "bzzr://3539fcd7906779bebfa61dec4b6fa5bdfe2ec2b47d0e75d571daaa5b895f0432"
      }
    ]
  },
  {
    "address": "0x46fe7a9c3269701e407c1bb68ed20ca456cf2d97",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract customIcoToken{\r\n    using SafeMath for uint256;\r\n\r\n    /* Events */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateToken(address indexed _to, uint256 _value);\r\n\r\n    // metadata\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals;\r\n\r\n    // contracts\r\n    address public ethFundDeposit;      // deposit address for ETH\r\n    address public tokenFundDeposit;\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public tokenFund;\r\n    uint256 public tokenExchangeRate;\r\n    uint256 public tokenCreationCap;\r\n    uint256 public tokenCreationMin;\r\n\r\n    /* Storage */\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    /* Getters */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /* Methods */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n  }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    /* Crowdsale methods */\r\n\r\n    /// @dev Accepts ether and creates new tokens.\r\n    function createTokens() payable external {\r\n      require (isFinalized == false);\r\n      require(block.number > fundingStartBlock);\r\n      require(block.number < fundingEndBlock);\r\n      require(msg.value > 0);\r\n\r\n      uint256 tokens = msg.value.mul(tokenExchangeRate);\r\n      uint256 checkedSupply = totalSupply.add(tokens);\r\n\r\n      // return money if something goes wrong\r\n      require(tokenCreationCap >= checkedSupply); // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      emit CreateToken(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    /// @dev Ends the funding period and sends the ETH home\r\n    function finalize() external {\r\n      require(isFinalized == false);\r\n      require(msg.sender == ethFundDeposit);\r\n      require(totalSupply > tokenCreationMin); // have to sell minimum to move to operational\r\n      require(block.number > fundingEndBlock || totalSupply == tokenCreationCap);\r\n      // move to operational\r\n      isFinalized = true;\r\n      assert(ethFundDeposit.send(address(this).balance)); // send the eth\r\n    }\r\n\r\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n    function refund() external {\r\n      require(isFinalized == false);                       // prevents refund if operational\r\n      require(block.number > fundingEndBlock); // prevents refund until sale period is over\r\n      require(totalSupply < tokenCreationMin); // no refunds if we sold enough\r\n      require(msg.sender != tokenFundDeposit);    // team not entitled to a refund\r\n      uint256 tokenVal = balances[msg.sender];\r\n      require(tokenVal > 0);\r\n      balances[msg.sender] = 0;\r\n      totalSupply = totalSupply.sub(tokenVal); // extra safe\r\n      uint256 ethVal = tokenVal / tokenExchangeRate; // should be safe; previous throws covers edges\r\n      emit LogRefund(msg.sender, ethVal); // log it\r\n      assert(msg.sender.send(ethVal)); // if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n    constructor(\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals,\r\n        address _ethFundDeposit,\r\n        address _tokenFundDeposit,\r\n        uint256 _tokenFund,\r\n        uint256 _tokenExchangeRate,\r\n        uint256 _tokenCreationCap,\r\n        uint256 _tokenCreationMin,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock) public\r\n    {\r\n      name = _name;\r\n      symbol = _symbol;\r\n      decimals = _decimals;\r\n      isFinalized = false;                   //controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      tokenFundDeposit = _tokenFundDeposit;\r\n      tokenFund = _tokenFund*10**decimals;\r\n      tokenExchangeRate = _tokenExchangeRate;\r\n      tokenCreationCap = _tokenCreationCap*10**decimals;\r\n      tokenCreationMin = _tokenCreationMin*10**decimals;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = tokenFund;\r\n      balances[tokenFundDeposit] = tokenFund;\r\n      emit CreateToken(tokenFundDeposit, tokenFund);\r\n    }\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_ethFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFund\",\"type\":\"uint256\"},{\"name\":\"_tokenExchangeRate\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationCap\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationMin\",\"type\":\"uint256\"},{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_fundingEndBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CreateToken\",\"type\":\"event\"}]",
        "ContractName": "customIcoToken",
        "CompilerVersion": "v0.4.24+commit.e67f0147",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000000000000000000000000000000000174876e80000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000022ecb25c0000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060ee74000000000000000000000000000000000000000000000000000000000000000e435245454b434f494e2043524b43000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000443524b4300000000000000000000000000000000000000000000000000000000",
        "Library": "",
        "SwarmSource": "bzzr://3539fcd7906779bebfa61dec4b6fa5bdfe2ec2b47d0e75d571daaa5b895f0432"
      }
    ]
  },
  {
    "address": "0xdff5d8f9b2aacd0b70a517c9de1d43d8b291c643",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract customIcoToken{\r\n    using SafeMath for uint256;\r\n\r\n    /* Events */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateToken(address indexed _to, uint256 _value);\r\n\r\n    // metadata\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals;\r\n\r\n    // contracts\r\n    address public ethFundDeposit;      // deposit address for ETH\r\n    address public tokenFundDeposit;\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public tokenFund;\r\n    uint256 public tokenExchangeRate;\r\n    uint256 public tokenCreationCap;\r\n    uint256 public tokenCreationMin;\r\n\r\n    /* Storage */\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    /* Getters */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /* Methods */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n  }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    /* Crowdsale methods */\r\n\r\n    /// @dev Accepts ether and creates new tokens.\r\n    function createTokens() payable external {\r\n      require (isFinalized == false);\r\n      require(block.number > fundingStartBlock);\r\n      require(block.number < fundingEndBlock);\r\n      require(msg.value > 0);\r\n\r\n      uint256 tokens = msg.value.mul(tokenExchangeRate);\r\n      uint256 checkedSupply = totalSupply.add(tokens);\r\n\r\n      // return money if something goes wrong\r\n      require(tokenCreationCap >= checkedSupply); // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      emit CreateToken(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    /// @dev Ends the funding period and sends the ETH home\r\n    function finalize() external {\r\n      require(isFinalized == false);\r\n      require(msg.sender == ethFundDeposit);\r\n      require(totalSupply > tokenCreationMin); // have to sell minimum to move to operational\r\n      require(block.number > fundingEndBlock || totalSupply == tokenCreationCap);\r\n      // move to operational\r\n      isFinalized = true;\r\n      assert(ethFundDeposit.send(address(this).balance)); // send the eth\r\n    }\r\n\r\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n    function refund() external {\r\n      require(isFinalized == false);                       // prevents refund if operational\r\n      require(block.number > fundingEndBlock); // prevents refund until sale period is over\r\n      require(totalSupply < tokenCreationMin); // no refunds if we sold enough\r\n      require(msg.sender != tokenFundDeposit);    // team not entitled to a refund\r\n      uint256 tokenVal = balances[msg.sender];\r\n      require(tokenVal > 0);\r\n      balances[msg.sender] = 0;\r\n      totalSupply = totalSupply.sub(tokenVal); // extra safe\r\n      uint256 ethVal = tokenVal / tokenExchangeRate; // should be safe; previous throws covers edges\r\n      emit LogRefund(msg.sender, ethVal); // log it\r\n      assert(msg.sender.send(ethVal)); // if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n    constructor(\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals,\r\n        address _ethFundDeposit,\r\n        address _tokenFundDeposit,\r\n        uint256 _tokenFund,\r\n        uint256 _tokenExchangeRate,\r\n        uint256 _tokenCreationCap,\r\n        uint256 _tokenCreationMin,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock) public\r\n    {\r\n      name = _name;\r\n      symbol = _symbol;\r\n      decimals = _decimals;\r\n      isFinalized = false;                   //controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      tokenFundDeposit = _tokenFundDeposit;\r\n      tokenFund = _tokenFund*10**decimals;\r\n      tokenExchangeRate = _tokenExchangeRate;\r\n      tokenCreationCap = _tokenCreationCap*10**decimals;\r\n      tokenCreationMin = _tokenCreationMin*10**decimals;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = tokenFund;\r\n      balances[tokenFundDeposit] = tokenFund;\r\n      emit CreateToken(tokenFundDeposit, tokenFund);\r\n    }\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_ethFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFund\",\"type\":\"uint256\"},{\"name\":\"_tokenExchangeRate\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationCap\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationMin\",\"type\":\"uint256\"},{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_fundingEndBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CreateToken\",\"type\":\"event\"}]",
        "ContractName": "customIcoToken",
        "CompilerVersion": "v0.4.24+commit.e67f0147",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000000000000000000000000000000000174876e80000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000022ecb25c0000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060ee74000000000000000000000000000000000000000000000000000000000000000e435245454b434f494e2043524b43000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000443524b4300000000000000000000000000000000000000000000000000000000",
        "Library": "",
        "SwarmSource": "bzzr://3539fcd7906779bebfa61dec4b6fa5bdfe2ec2b47d0e75d571daaa5b895f0432"
      }
    ]
  },
  {
    "address": "0x82e3f878152437cf0788fe4669405e4fec59a681",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract customIcoToken{\r\n    using SafeMath for uint256;\r\n\r\n    /* Events */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateToken(address indexed _to, uint256 _value);\r\n\r\n    // metadata\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals;\r\n\r\n    // contracts\r\n    address public ethFundDeposit;      // deposit address for ETH\r\n    address public tokenFundDeposit;\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public tokenFund;\r\n    uint256 public tokenExchangeRate;\r\n    uint256 public tokenCreationCap;\r\n    uint256 public tokenCreationMin;\r\n\r\n    /* Storage */\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    /* Getters */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /* Methods */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n  }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    /* Crowdsale methods */\r\n\r\n    /// @dev Accepts ether and creates new tokens.\r\n    function createTokens() payable external {\r\n      require (isFinalized == false);\r\n      require(block.number > fundingStartBlock);\r\n      require(block.number < fundingEndBlock);\r\n      require(msg.value > 0);\r\n\r\n      uint256 tokens = msg.value.mul(tokenExchangeRate);\r\n      uint256 checkedSupply = totalSupply.add(tokens);\r\n\r\n      // return money if something goes wrong\r\n      require(tokenCreationCap >= checkedSupply); // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      emit CreateToken(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    /// @dev Ends the funding period and sends the ETH home\r\n    function finalize() external {\r\n      require(isFinalized == false);\r\n      require(msg.sender == ethFundDeposit);\r\n      require(totalSupply > tokenCreationMin); // have to sell minimum to move to operational\r\n      require(block.number > fundingEndBlock || totalSupply == tokenCreationCap);\r\n      // move to operational\r\n      isFinalized = true;\r\n      assert(ethFundDeposit.send(address(this).balance)); // send the eth\r\n    }\r\n\r\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n    function refund() external {\r\n      require(isFinalized == false);                       // prevents refund if operational\r\n      require(block.number > fundingEndBlock); // prevents refund until sale period is over\r\n      require(totalSupply < tokenCreationMin); // no refunds if we sold enough\r\n      require(msg.sender != tokenFundDeposit);    // team not entitled to a refund\r\n      uint256 tokenVal = balances[msg.sender];\r\n      require(tokenVal > 0);\r\n      balances[msg.sender] = 0;\r\n      totalSupply = totalSupply.sub(tokenVal); // extra safe\r\n      uint256 ethVal = tokenVal / tokenExchangeRate; // should be safe; previous throws covers edges\r\n      emit LogRefund(msg.sender, ethVal); // log it\r\n      assert(msg.sender.send(ethVal)); // if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n    constructor(\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals,\r\n        address _ethFundDeposit,\r\n        address _tokenFundDeposit,\r\n        uint256 _tokenFund,\r\n        uint256 _tokenExchangeRate,\r\n        uint256 _tokenCreationCap,\r\n        uint256 _tokenCreationMin,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock) public\r\n    {\r\n      name = _name;\r\n      symbol = _symbol;\r\n      decimals = _decimals;\r\n      isFinalized = false;                   //controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      tokenFundDeposit = _tokenFundDeposit;\r\n      tokenFund = _tokenFund*10**decimals;\r\n      tokenExchangeRate = _tokenExchangeRate;\r\n      tokenCreationCap = _tokenCreationCap*10**decimals;\r\n      tokenCreationMin = _tokenCreationMin*10**decimals;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = tokenFund;\r\n      balances[tokenFundDeposit] = tokenFund;\r\n      emit CreateToken(tokenFundDeposit, tokenFund);\r\n    }\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_ethFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFund\",\"type\":\"uint256\"},{\"name\":\"_tokenExchangeRate\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationCap\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationMin\",\"type\":\"uint256\"},{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_fundingEndBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CreateToken\",\"type\":\"event\"}]",
        "ContractName": "customIcoToken",
        "CompilerVersion": "v0.4.24+commit.e67f0147",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000000000000000000000000000000000174876e80000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000022ecb25c0000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060ee74000000000000000000000000000000000000000000000000000000000000000e435245454b434f494e2043524b43000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000443524b4300000000000000000000000000000000000000000000000000000000",
        "Library": "",
        "SwarmSource": "bzzr://3539fcd7906779bebfa61dec4b6fa5bdfe2ec2b47d0e75d571daaa5b895f0432"
      }
    ]
  },
  {
    "address": "0x7ed11b7130d838ca8d9b79734a11ed0692761362",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract customIcoToken{\r\n    using SafeMath for uint256;\r\n\r\n    /* Events */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateToken(address indexed _to, uint256 _value);\r\n\r\n    // metadata\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals;\r\n\r\n    // contracts\r\n    address public ethFundDeposit;      // deposit address for ETH\r\n    address public tokenFundDeposit;\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public tokenFund;\r\n    uint256 public tokenExchangeRate;\r\n    uint256 public tokenCreationCap;\r\n    uint256 public tokenCreationMin;\r\n\r\n    /* Storage */\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    /* Getters */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /* Methods */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n  }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    /* Crowdsale methods */\r\n\r\n    /// @dev Accepts ether and creates new tokens.\r\n    function createTokens() payable external {\r\n      require (isFinalized == false);\r\n      require(block.number > fundingStartBlock);\r\n      require(block.number < fundingEndBlock);\r\n      require(msg.value > 0);\r\n\r\n      uint256 tokens = msg.value.mul(tokenExchangeRate);\r\n      uint256 checkedSupply = totalSupply.add(tokens);\r\n\r\n      // return money if something goes wrong\r\n      require(tokenCreationCap >= checkedSupply); // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      emit CreateToken(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    /// @dev Ends the funding period and sends the ETH home\r\n    function finalize() external {\r\n      require(isFinalized == false);\r\n      require(msg.sender == ethFundDeposit);\r\n      require(totalSupply > tokenCreationMin); // have to sell minimum to move to operational\r\n      require(block.number > fundingEndBlock || totalSupply == tokenCreationCap);\r\n      // move to operational\r\n      isFinalized = true;\r\n      assert(ethFundDeposit.send(address(this).balance)); // send the eth\r\n    }\r\n\r\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n    function refund() external {\r\n      require(isFinalized == false);                       // prevents refund if operational\r\n      require(block.number > fundingEndBlock); // prevents refund until sale period is over\r\n      require(totalSupply < tokenCreationMin); // no refunds if we sold enough\r\n      require(msg.sender != tokenFundDeposit);    // team not entitled to a refund\r\n      uint256 tokenVal = balances[msg.sender];\r\n      require(tokenVal > 0);\r\n      balances[msg.sender] = 0;\r\n      totalSupply = totalSupply.sub(tokenVal); // extra safe\r\n      uint256 ethVal = tokenVal / tokenExchangeRate; // should be safe; previous throws covers edges\r\n      emit LogRefund(msg.sender, ethVal); // log it\r\n      assert(msg.sender.send(ethVal)); // if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n    constructor(\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals,\r\n        address _ethFundDeposit,\r\n        address _tokenFundDeposit,\r\n        uint256 _tokenFund,\r\n        uint256 _tokenExchangeRate,\r\n        uint256 _tokenCreationCap,\r\n        uint256 _tokenCreationMin,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock) public\r\n    {\r\n      name = _name;\r\n      symbol = _symbol;\r\n      decimals = _decimals;\r\n      isFinalized = false;                   //controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      tokenFundDeposit = _tokenFundDeposit;\r\n      tokenFund = _tokenFund*10**decimals;\r\n      tokenExchangeRate = _tokenExchangeRate;\r\n      tokenCreationCap = _tokenCreationCap*10**decimals;\r\n      tokenCreationMin = _tokenCreationMin*10**decimals;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = tokenFund;\r\n      balances[tokenFundDeposit] = tokenFund;\r\n      emit CreateToken(tokenFundDeposit, tokenFund);\r\n    }\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_ethFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFund\",\"type\":\"uint256\"},{\"name\":\"_tokenExchangeRate\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationCap\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationMin\",\"type\":\"uint256\"},{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_fundingEndBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CreateToken\",\"type\":\"event\"}]",
        "ContractName": "customIcoToken",
        "CompilerVersion": "v0.4.24+commit.e67f0147",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000000000000000000000000000000000174876e80000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000022ecb25c0000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060ee74000000000000000000000000000000000000000000000000000000000000000e435245454b434f494e2043524b43000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000443524b4300000000000000000000000000000000000000000000000000000000",
        "Library": "",
        "SwarmSource": "bzzr://3539fcd7906779bebfa61dec4b6fa5bdfe2ec2b47d0e75d571daaa5b895f0432"
      }
    ]
  },
  {
    "address": "0xb74764da79d91194e07849b9743501913b68c89e",
    "result": [
      {
        "SourceCode": "pragma solidity 0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract customIcoToken{\r\n    using SafeMath for uint256;\r\n\r\n    /* Events */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateToken(address indexed _to, uint256 _value);\r\n\r\n    // metadata\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals;\r\n\r\n    // contracts\r\n    address public ethFundDeposit;      // deposit address for ETH\r\n    address public tokenFundDeposit;\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public tokenFund;\r\n    uint256 public tokenExchangeRate;\r\n    uint256 public tokenCreationCap;\r\n    uint256 public tokenCreationMin;\r\n\r\n    /* Storage */\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    /* Getters */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /* Methods */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n  }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n    }\r\n\r\n    /* Crowdsale methods */\r\n\r\n    /// @dev Accepts ether and creates new tokens.\r\n    function createTokens() payable external {\r\n      require (isFinalized == false);\r\n      require(block.number > fundingStartBlock);\r\n      require(block.number < fundingEndBlock);\r\n      require(msg.value > 0);\r\n\r\n      uint256 tokens = msg.value.mul(tokenExchangeRate);\r\n      uint256 checkedSupply = totalSupply.add(tokens);\r\n\r\n      // return money if something goes wrong\r\n      require(tokenCreationCap >= checkedSupply); // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      emit CreateToken(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    /// @dev Ends the funding period and sends the ETH home\r\n    function finalize() external {\r\n      require(isFinalized == false);\r\n      require(msg.sender == ethFundDeposit);\r\n      require(totalSupply > tokenCreationMin); // have to sell minimum to move to operational\r\n      require(block.number > fundingEndBlock || totalSupply == tokenCreationCap);\r\n      // move to operational\r\n      isFinalized = true;\r\n      assert(ethFundDeposit.send(address(this).balance)); // send the eth\r\n    }\r\n\r\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n    function refund() external {\r\n      require(isFinalized == false);                       // prevents refund if operational\r\n      require(block.number > fundingEndBlock); // prevents refund until sale period is over\r\n      require(totalSupply < tokenCreationMin); // no refunds if we sold enough\r\n      require(msg.sender != tokenFundDeposit);    // team not entitled to a refund\r\n      uint256 tokenVal = balances[msg.sender];\r\n      require(tokenVal > 0);\r\n      balances[msg.sender] = 0;\r\n      totalSupply = totalSupply.sub(tokenVal); // extra safe\r\n      uint256 ethVal = tokenVal / tokenExchangeRate; // should be safe; previous throws covers edges\r\n      emit LogRefund(msg.sender, ethVal); // log it\r\n      assert(msg.sender.send(ethVal)); // if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n    constructor(\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals,\r\n        address _ethFundDeposit,\r\n        address _tokenFundDeposit,\r\n        uint256 _tokenFund,\r\n        uint256 _tokenExchangeRate,\r\n        uint256 _tokenCreationCap,\r\n        uint256 _tokenCreationMin,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock) public\r\n    {\r\n      name = _name;\r\n      symbol = _symbol;\r\n      decimals = _decimals;\r\n      isFinalized = false;                   //controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      tokenFundDeposit = _tokenFundDeposit;\r\n      tokenFund = _tokenFund*10**decimals;\r\n      tokenExchangeRate = _tokenExchangeRate;\r\n      tokenCreationCap = _tokenCreationCap*10**decimals;\r\n      tokenCreationMin = _tokenCreationMin*10**decimals;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = tokenFund;\r\n      balances[tokenFundDeposit] = tokenFund;\r\n      emit CreateToken(tokenFundDeposit, tokenFund);\r\n    }\r\n}",
        "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_ethFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFundDeposit\",\"type\":\"address\"},{\"name\":\"_tokenFund\",\"type\":\"uint256\"},{\"name\":\"_tokenExchangeRate\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationCap\",\"type\":\"uint256\"},{\"name\":\"_tokenCreationMin\",\"type\":\"uint256\"},{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_fundingEndBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CreateToken\",\"type\":\"event\"}]",
        "ContractName": "customIcoToken",
        "CompilerVersion": "v0.4.24+commit.e67f0147",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000c2eb5534c9754d2adc69638d2a4c09decbadab36000000000000000000000000000000000000000000000000000000174876e80000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000022ecb25c0000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060ee74000000000000000000000000000000000000000000000000000000000000000e435245454b434f494e2043524b43000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000443524b4300000000000000000000000000000000000000000000000000000000",
        "Library": "",
        "SwarmSource": "bzzr://3539fcd7906779bebfa61dec4b6fa5bdfe2ec2b47d0e75d571daaa5b895f0432"
      }
    ]
  },
  {
    "address": "0xc2f51820454ace6a7b7529095d46aa0a3fddd0d9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc7dd551f27a83da24664d0f541edaad6f7d7ec7d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc16eb677ef4be117da93b1dd2be7d595e15cd9e7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x33537d440a2d2814b23d175b9330d7570b63c5fe",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x395623b39e6bf92037e77d465ec213a433f3c1d6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x31f7db1ee7351503893f2dc1b59f5f9b2df036bd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa80a1ed0f6ae5dd3d8c4c266bac7095d470df624",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9006dd7ee5a60609d1eef25d73bd43c19a112f64",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6e7497b40cd39241651fd1032579df7da11b35d7",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf0b8c4feb5df197674af805e4b04010b6d5fcc01",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xba1e96dc9deb349e31cd70b3a3ac8767dd16ac31",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf7574661b074a69b145c25caf64ab593139bb4cc",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2573f7ed35f36318480b554695c1053e6ce50581",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6c7c4b77308b1249de2186b22730859686912595",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7f98beb4f3c6891dc3c056c689414530c21a5267",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x03f8dd8b9df92660a379d25db4761130cc0f7732",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9f06635901810f66c6885042eaf03ddeae3129d9",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x13b2135c71cb3797e5fc8c46770553086414fd68",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0c392d32e14a054223c940affc941f4ea6cfe548",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7f9d0242b144f0d53da95c22b9b4db5c767b99fe",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x83a2e1ce56b67eb65e848c2a08b2a39c9a7a4448",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x281d4c7dee4ec1eb75daa6c283be9e6bbd510685",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3041c64b5cd7f8251684de9253e775601546ca82",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6433b912bf1ca054d88d16418e5773c3d3a50ec9",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x00a13cf8013f8855fb56f1646eb1cd7ad612c04f",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc6e1c9d5e178d7919947747b30631c48aa4093a1",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7caf5d388a0faef7da384a049bd88e1ce8f0ac6a",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x090c7e086cfc0d66443f40193c144a144e928478",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7e40cc11c05abc3789d63edbb330db37318cc6a7",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x506e31c8fc5ed48cc023f4a683d5911723f36797",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2053a75809eb9aabb71c42fde10c0474f5a5c0cb",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x35737db9be26d2d12c177da0e61811bd4b033f67",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdd0498927a7ec387af2e5e90b791789aeb8990b2",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x37e24a0de36821c32bf119f04ad37c661105c7b6",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xee4717731d50dc3a20ddddb4abcf569d8ae9a644",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe0f92ef94ade3215cfa2213aec23f1452ae2813e",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6573751117e1e692c10d057318679e55fefd83a8",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x131c8e15afee2efa7cc53648beff583a5621f087",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5829cb154cbbab631d74a11414286351128edf9b",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa945a2b1c653287495b5e6d168ba11a32ec5cbff",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdd1bf65303cab3f5f5b7ffa1f678b987a19c9d34",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5e48a896ecb291ec5697c15f7b7fefc49f192b5d",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x15995af69a871ba16da282888e5654daeb3deb4a",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd06edefa7cd3feabf639b541a3ab45722e8316dc",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc8a2f4df90a6c11af0bfa11817d60bad760f2c02",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc078288ad1325f2af7d1decb74830c072563e087",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc296f2538a4bb88f5e29ee5beecaeea004de73fb",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8f5bec485138eebd33cee09a7d98f8fd41add100",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf6963d77383798dd0dc76009718092f07d89089c",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x70019016856550e5b13eed713e6589fae68b3141",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa23a29e43755696c0ee3177b3fa36092caab2da5",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xeb1405440f19fc604553d24299e2a5e02063864c",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe33351b8c2478b857d6bd96b65f8071dde547cb8",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xaa2dca57cc45cc9ea4d857d3b38c38b2e4e32b1c",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7faa9ab7a1fb29b3ebcdbd1f16919e9ef3905100",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4a94e3102f130feabee845646f891982f6902dae",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe769e3104b160b583776c8dfa743c467fab53d48",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc625fe5877e1e42ea4c687670e9df023bde9dab6",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf881425b5fb7baeca02e06fc5ead59f70cc94dcf",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x86a12f8f6805cfdd2147f01603bc079d78b8bba9",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x78ed09592bae583527dbeda4b46ad690fb9a73ec",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbec2cbc06118adc49884b0f1235d902ba55fdbb9",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe999f8471307b81cd89c8a937777a323acbac1f2",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb3f6e08fd2b192fff3ac7073bfd625667fcaeb39",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x625c2b599529f858c7e92dab736d4e847ef1c350",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x063d09bcd46a14b1d39a2480d7d244837efce8bf",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2b3ab2fdb0b9111d25ebd6724bd1b56c04b80796",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x75dfb1e3885d2e51729e7d04ec137a9ed3a32d28",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe46f88f1cabf54ad2a992e66a943e48c1b42e5cb",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1d00fbbe45fb74b9e020fc5086f6ef0ccfaed7a3",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe12d125af152067df935130d1415b36eec260d87",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3b43f9f6ac65af404e89adc0b7321a85c92a51c0",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0e514dd1047d427b619bafb08704e031eccce521",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x974a6e2035d17ce557cdb6451960a1dd2645ed9a",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x96741f3ed4df6f16e6fdbbeb6c11bc79cb42aeff",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa10bc62f8649b36c4726d79f1303ba9a1fc3d88d",
    "result": [
      {
        "SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
        "ContractName": "Wallet",
        "CompilerVersion": "v0.3.2+commit.81ae2a7",
        "OptimizationUsed": "0",
        "Runs": "200",
        "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xba303cd3bf57e7f4949664b6b2ac490a54d10ee3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x61c8d25a01dc5696922d4b5a955be1da8cfb0ece",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xba2e204b054d5ad9eaec6b18ba5a92609436d4e3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2db0f72d49ed6f868bf380f42a78a5692ed2e95e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb2c8228d93090e8797e007f045930aa1bf074d70",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf3f6367b3c86d682aea638c0d8c93c392156c297",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2030a46a2356cdec3795f45ff41861eae3448849",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x49323b3774d3fe3604ad26b3e717f1bd781b2bdf",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x97828373787a2435341bce6190bbf71fdc62401e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8adde0fb483e2c9636355d301a6c4865ce95bdde",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb33cb172ac9fe3c9ce964d042ba4956165b274f8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7468951e22e5cc9293df5131b9debb5716ffc2ad",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9f01164341f3162679e674cfa04f565d251e52ff",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x32cbeef752ea47ec1efa93ccd3aa1f700d891e89",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xeb0a1b3cafb7d375767e0e742f33efa7583bc9f0",
    "result": [
      {
        "SourceCode": "contract SimpleStorage {\r\n  uint storedData;\r\n\r\n  function set(uint x) {\r\n    storedData = x;\r\n  }\r\n\r\n  function get() constant returns (uint retVal) {\r\n    return storedData;\r\n  }\r\n}",
        "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"set\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get\",\"outputs\":[{\"name\":\"retVal\",\"type\":\"uint256\"}],\"type\":\"function\"}]",
        "ContractName": "SimpleStorage",
        "CompilerVersion": "v0.3.5-2016-07-01-48238c9",
        "OptimizationUsed": "1",
        "Runs": "200",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcc1e957042af104f8e0058c0a067dc95b2adab32",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x516c8b26a1bafc07d3ab4353ff79cdf13f943e6b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8881175c48023d9e0661f4f12c1b106aab5d4fa8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe22cf293d4bd41a0a37be67c51b99babb9d8d4e7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xffce8eeabfeaacbd80cb7d5a5acf161e93b0cd54",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf88e5d3cd7053130c0fbe01b122f74e085165138",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb74e64980e7d6b997fdeef96e476bcbd38d90854",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x81d7c73be7d205ec75828a897aa00e76233b59be",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x31c82cc257ee8dbcba6ea8e25d28d3bae557654a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf7c8ce2c92f7fa12f026431960a33e28934807fa",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc8005ea62cda1f570a55d3049e2ab162cda626f6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x93bf3fa4c33cf0516af8d04a427af9dca1ab19c3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdb2444cef6cf31dec19de732f8a98916b78a90d3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcca01521df903bdbdbb645946ffe4ad78d5969b9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe5b914c22fcaec9ad8fe79e2f6e41ba06aefa2c9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa574cfc696366e90411bac19d58cd8728af98e6e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7a72b54e45829d7a42e4f246419470832cc6c147",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf7da3412b26eb6d685b9053acf338e04ac65bfc1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3537ed8f4c0db2b352af8465d7969c663d857f3a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xef308ace72d08e0f5984bcd9ef366cfecbc88da1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc34c512c9cf43938ed90d1de5daf819438a513e9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa50fb74ec751d81203b784295dc87f2f5b654866",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xaae2f4ce5510e616c8acda52ad641b66e6052a9e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa56dbab4ea03a41531b967661d6c71c05032bbf9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd89a3a108b8e92fd04400a871a336aa5523ef662",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0680f2f2a1209d4e93631da783ddb3c521c063f8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x83a43442799705dbd2250188dc54cfaca3200528",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa836e8d791ea755513c8969aafe77c17b1c73e40",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0a023f524ba7ff4298fe3cbd7ee841f35657a020",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x037db316e0f8b22439311a4baeaba44379baf9ab",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xee7b5d1ff8ac7247e939ebc1ff56573fe4a24839",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb82e4685db24fa7d06cc453dded0150c8aaf0a63",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x62aa9f9c4255be683b17bfd6227e6666f7ba9080",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6f7f12fa0186a5391b2f9d51729d5f0800bb3527",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7daf121b8b884765e2dfa05997873c05f8c18b20",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x449e3f05ce77117226040a095fd9e2ed8c7f366d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd69fe5972c218ce76f5723a74c2b72eb64c9faf7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3859f9eaf67f1a09f4c61332348052949b0cfa3e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbef2d7bfc665bc569539a6e5035dfb57a23500a3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5235055b59f375c98fc26487b472ffbfa6f0c10b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xeb21bd9cccd0db4e1934b039443b08567a587f04",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6907e1e7f64b74a02b7f9ee6892690254ff4c39d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa27f61a08c30c81051e5c6a5071ce16b182a2446",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe04d50673d0e5cf4fbc15eb7e67a3ffa95d00bf3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe0c368e8aa7369c9f8aa56d4726d521aed0af44a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa5d22c06085ffe5aa42e489c25ce9bd4b8853a12",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6b49bd8ca781864c3255392530eab6bdf0e26cf6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbe246d1cebc040deecfa78e29f63a4d0df31f289",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2717f4b6a7402d8df135909dc88e8c152db7f9a9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x72aa903f1b3db6d6d7c7b3e1401e6e76698a899a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe9b688844a9f58befccea1e3d49759d1460ae799",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf6dfdad90065563b78587e47948f463f18f495e0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4592d77fc06d7f3c977760539ab8db067aefe911",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb961f20acda7f30cb701ade42a44a3eaa9382eeb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe0e01780989d78ff359e13be3227f1c3df943b69",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x67a9178c1ff90686f4b4b3f2f07d52f303406ed4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3e790b9dd864fefe17d3c848d64eb4fec50bb9e7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xafb7616442ba9cc5fd2514676520f0d47fd152a5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc7855da4fe5680e2cfe9cd50a4fac6b2d18f3e28",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x442dec68dfa47a554c672ec41b12e07b07856fbd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x28134a6a0ae2944f0b0ce1b5339fd2b8cf423bf2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x35243697ac3c6c4f48a38c73fd6e0cf729d64cce",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7ee30e3b92cb45da55e52032faa41eeed531c056",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1a7daa69051486fb24b79c573dcc8f7f4dead305",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x208f625c9e6782e526b01b9d391ef8a4fe89e6ad",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5675790a17f3972465a6a686eef9e9bd5c801679",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf51cb907e97b745121fd3d38944b4261a3e47d44",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe3068cd3cac5003cc68e961dae7f6d001a503cd9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb2256361d4051df070282e9f121f2e3d6c1727e9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x32d798fa7f6e499118a88450e028594034d6062d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4e859acbb1f581ca36eef129a1615f2ad5d49380",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5639c12155cdc9aec07cc349f43f35dfd95969d0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfe69873e565c144b4ce7fe457b9e0514aa2da39a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x43604dc631561209c14667cd0dd960a5e8806f24",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfdf553b889a314ba0bd0da6428c28257a03d0111",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8493aa64a3a163f694b413b7f856d4ea3eb95af3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x486042d3bf3ba1608eaf3c41fe7f0c14a84a30f6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5016dc8b2e8bc9aaabfc6837e5bf041177fafcc0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x21c2ab7a8aa9b5aa95c23fe64c1986ff0c378f42",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x48a496bedcc451231352c10f64e8038d4d5826db",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1bf2824786b6b203541aae3bc0abaeef9c809058",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf66ff4d78762fc786574f357d968e22bf067490d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0c3491967f644d112d582689bec7a5da55983655",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd2b1a1d0598a1c9059cc976f9056715d5673f91f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x210f558bc460839823f4b9bca7ff48279ce5fde8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x443ffb273210014769b3862ae7dbbf879ff1b91d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x73968e8edd9301178b3c8a733b5a55fce1788c49",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xff19c5e7babc3d3638399cdf85189a2b686b616e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xab833cd8c38f2988c9ef9b5d6c465c0f13237edd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x37220391e511e19238d93cde1d18d68d332394f4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc4b6724ca33a9463aed373bd3361511529f32adb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x20a3da2a0837f935bc55b1cc2c3deeafd77bbf39",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x684c948a88d89e07b7e64499f7ca65e0952aa5af",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x313c4511a36a26516833ab3914f9f9ddbf3fce72",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcbb06aa5dbb9ddb0d20bdecd7eab26dd2319f44b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe8d36f6492d74d9a4c4ae155ecbca4febcc80e1d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa5bcb145e5ee99d77eee4060632a725a25f2c7ad",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x44188aba4e39ca99409ab90e5d8d072d51737eb1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2b669c758d4403abfe6eea73efa66541af892beb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3bf72bb68f5eb144e947484b706ca250e68a6246",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x790e8bfee15c8630acee6358163da592a2576cd9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x18e7a30921d02cd028dd1c195e20e3e428363e0b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4ff36f3d5bb7239f03dc512bd0beb7b215e8f7ab",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x76aa6be8391ebbdd1987a1f4b0b2a5238a17d4eb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x78bb120af36a427b186dbc6f5905944f331aa934",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb4bb51e8064e0e81cb1ce258b5f33ecfe5d97cbb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf593a9e81a90ff4c3ebccaa8ba1f33d8bd70f624",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xac28354057c3168baa9161ec5e280225ef229c40",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1d314ede2b928f6b3cbe2ad5d2f7adb2ec299eb6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x368593ac0df317c72f911f2e741da5b80e941d47",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7f05783a73eedcefb253938a50c9d1714d6d105e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5dc99a4ffa79160748e05eb81861091a0df6f826",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x60baddeb8738d8ccc82664501dd3b566fd5087c2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe1e4a83651a9f584ac841cd5ac360e9bcd51c904",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x64005735c07307351fe9b9e34f246dd6111377fe",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x971e588fbdefd2a2a6d58313eaa0cc1333a08181",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9a17b2dcd6d441a8c3311c36df912b4c4bf03453",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x08222ba995a2ba953cbdc6beae5afdded6165e05",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4c1434c5eedc50363b7f108ef311086c4bd0f64f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xeb2193054abf864be52c5e87cf15eff81282058b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x58893cef2b6e062841ece24e4b891d3a396c07cb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xac4ccc940936f40f907c0a13bb901391c22a366d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe25451256374055b55e249021de653e96d97320a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8562a555f868746ed780b6c2ca784f98e59c938d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x53e32617699db876fc06c30a60faef04728c8be4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf6b3e52551cf0de27d557ae2a409d5691078cff4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xef8ddd9940937ae2cb781415cf0966fff4078d18",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x73f1718cbb4c933c244a0fe84322bb843f5d2b43",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x44f1964afb5ee05aade79087875d3df9b443b1d2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9e40afe3ff693078b7ed83076ff730d0a02c5298",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4aad89b771f61ba27e1f0d9648c6556a69b4ea4c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7901876f62477e4e877ee3822e8d96d0265ac3e0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xda5e604f80b6468ac5d1845579f5d959b5a375d2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x08db38b67737b61262a440ea4a64c11cbadc95c6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x77786f3793a434346bad850293f94718d7af36d3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5def75eca6062f6e21c3cf0acd2f550e1bb93584",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x394f44891526048c1450c3d0437f0ca189281bd1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x80a1615c75e7051be8455df4c49c76bbecc230ad",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xaf2e19c02b3703c701fdea9be69a7bcd08db13a0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2f0d7e4328663d21062b0007c407ea7271adf52d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x155a5cbcab0a2851a7607aaabbd66e7d24e2b6d5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x458a4f18b82f4c4c54ea2ed83f22ec26df6855b6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7e36ad98a7be022e50d9440d6b007df4c7fcae95",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf461816849b411339c7fb02943ee2551e61ddcf0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1657335bef02be274bc5c6f4675f56d0ce73b60a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6c4bd8d30a4b4db8db74c13644ec8a045d31d147",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x96ee05a39b08df2a8e5b83cca4825a3d3b16db2c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xebe62ccc3310307486b8f2a4eb5cb1f5ed80abf7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe610028c89b9795686f9a8bca9d0e171663934d4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x955973803051a4fa8d74cbc7eb4796547998f282",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x66b3db3cd55cd2ad9938386fa9f729efe913df4a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8e242e6b6c69f2d1eb4a608f6d55a3362ae306de",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x41c070067b4451cddb1bd97843248e605c359f85",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x66ca12a64106abed2f6c3bf0cc5948b928fc4393",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8efa3f1ff2c8efa3648f6b732ad90055767eb7e9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xab7f19fc051dbd6e0e1f532f68eef2cd4e2c7f20",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4b9d4f30dfa7a6e252f246ebe239895c2eb4403d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa1f5a7d2290fc3dc0a944f41cf102d0b2a4993af",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8df3d905500c5b85708fb25c7c2ba70de70bede7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc482609512f16e08aeed2f23a0f673ae3f92bdcd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xae83bfd5272e3d9ed17d9e20bccf87355a5cc76a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5eafefc624619e1920bb81d82a8bed23a476abb0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x06db36b0f7a089fd7d0f27c4798af708f5218755",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3677d4bf5ba39460049927a7e7424f7b8bc4224c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb2ef34c03e48ecf480b2eb6343e4f87bdc4c936d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4d3dc145304ba78d92f530b62b1a9c7c981ad2f0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb819a5b343f85779bd50baced26c8d94a8ca27a2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2b0685586e0342f7cef7e35214dceafe8b377449",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe41f996b80b73c035a80567c5ebcb60621b068ae",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xebe43111d17edc21b4a62ea572fe4affb411ae41",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x96d9fba424cee16e3c963f05a06ff9c5ff0d10ac",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x211a07219897384d2578105766a04fd7e2e918b7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd580a991e54781c3f944afdf2f4f01c6e81fc0b1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x87028c7ffb0b295dfbe11e3b01eec8e9123e7061",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfd762c218da2b91100a063952459c36a7ba29ecf",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc9b264a97c7ac383eab70e566a879ba254d2d872",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x66f60330c295e6418d2961185a87a9161b17ca8c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x60ca8dd6ba5477f56f382e7bc16ab22cb33f74ee",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1c987bce909200ceb5228a791f944c860ec402a6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9dbab7d656699b30788da7498c08671e6502afd0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6c8f0e5a29e057440a11f8e284b1ad6b058adf84",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x334c0b923ec41c439983ad3753fe90c7df72e60c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x075f98114a59b3b938b388352c3f5e67ccf69d15",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4444a260779f53fc06f055d396f80c47489a5a4c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4de15182540d4be13e37cec221d1d51d1b1e2ad3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xce7114be1bc4eff156e9410c7498d521c210fe5d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5f79540c107293ef6399b3b8a337667c12ff7bfe",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x19340a18688c3d433cde1f8cb57fe596934ab0c9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x02525f977ed3a54d3b28eca69a4209fc19e3c6ec",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9bff00c2e17b4f53a9bbf42e954ee6b94fde8e26",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x37adb8a5b4ed966506ec381cc2e0d7e464f444c6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6120c55e9d31f8ab01e85d03599e3de451bc0ff3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf9582a65699ec492f2824a6685326d3477896601",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xef13b302db1019477ffedaa0885394d83f7bb653",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4a683c7abdb76fc8ab76da6a99f9d21369cfe903",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd4a6e41b9c6976f7b5689d195a36b1acdecc60a1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x36c916ee84fc51ee92f9071e137d1be62ce47142",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x65675e66d4d6471890afd09b284e37caf6600fd5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe8ee61d54624ddb7234864018367b78af84ab641",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x62edf989e8769ad7c1033c93b348a7992f5ee8f4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9b0cc2116e75c184e4dc5c1d2f30c2d0cdb4134e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe20a1c445a76b35c7139687d63d1ff6c2acaf04c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1bfb89b6ae0714ca4dd5d2ebc051fdab15d8d301",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3564f5a1c9f3cb665ee99c37c376abb305eb3ae1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb22d0e427d931e1432bfff24f5fad93fe1f3c252",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcb549efab8fa4d1dd9947d981ead79708f9d7003",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8e3ebdaa861b00ef9adb598b1ccd99a16f82db7a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7f5ee53587d8ec83f883b057ea2e49c6b1672b94",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa4d737ea086933bead4eaa1d76701073f615f05c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd776030254bb58709cbb810c4f4fe96867fb9444",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x134283ca36eba18abca34d9a4e9e3357f76772de",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1c700bddf5ca100f6f56f126c0ed4b8f76661094",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4f6afe7da73261ced0b631c13994fa1fbd9b07b7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x638d7f85c202425ab4d6ac8abff51ecb1dac2146",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa6db1ddbd239e20a7ce91295ba56dffcace87d36",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x450f4d077c2c55d3be9c4a473231227b7a6ef8de",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x130e2eb3291cad96f6a99fe3863b6c878ccde44b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x56dbb82a33933e494d4d9882675e386d321ce28a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x03ea462716cc09427c58846fc847d568f7d557e7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa3be64fa2bbecfb2d5ce0a5fab0719c5b3bf0948",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x82290c4de57825f85e0d9d53c912b39f580766e2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xec22122b8a8a35e0081f71350bc42b1e3734a13b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x080bcda22f58b40a13dd6b2894ba63a419e45afb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x24084cc7ccaf6f9b556633f573d42c7275844cfc",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf4ab7c1923b856a5c772374bafd3765618b89510",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4b42093ed018282436631d615e56cb6fd2ae743c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe8157a641c1a77788109f7d32dea545d9b9572ae",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf9e21410b6f094044150140738b298f684bafa66",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc11677f623da68b11e00d604ff90a9d4c6c62655",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x30e60493592606915e96a7842ce21d073fe46285",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1a11aaef258ee8a23c2f21500ddc79f5cae9717b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x232202e2017a82ebee13bc60a5ba47684a623e88",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x88842affdeaf360e9f88f610afac95c5382a7368",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xaa3e1650b5d752457ddb468148831baadbf8c997",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3ea1afaffa4d28d104e2283b0836921d7d260b9f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x09dfd407b63cd5bf7add5828162ebadcf63c6292",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3b1296f8e9e3c06c7246a502365f7c2a85a17476",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf5e9d46b2985aa2c82989e24db45866bb7252f37",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x267de1bb76e717dde862e6d9ca1e54ef308aeec1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0a539d7131ca37006abdb45db1b44d121abadfe8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4a363563049e786b8a3d9fae93634da9ed9bd6ae",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb4aad711553d1ec30d22b1f70fa1b94dc4f446d5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf20e569776e6669965468bed20f9f1f365a9f141",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xde4721cc7de3a103eadff537c02e242172bcac79",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xce67c5a1e14c2e06a2d07e37eb8043ea4533cd86",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe93c21a198028a08877aaebc14b3fec22119c446",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xac427db1982ac7efaaa4a8f1f424d953f85ffc5c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x62d45a9f96d8e551646904aedfa0d0cc13c01a9a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfe95a4ed56ed8c10d7617a708a8dfad527616748",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xae76bfcf89da583f78a9d040859b09cd990ed73d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6133ef0fb368c20c90db8899b42beacb4ac8f629",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x25491e2f7bc93c5b98b6d77bee168cdb601bee86",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd9fae6fd04cba0aea4793bbf756658fd915eed0a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x43c3163ab6eddf22b77abfc144ed905533d48b71",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x06a5972ab409749196d11d2614aef893ae32f459",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9956c2c2669862a92981e5e7eebca10e587cee8a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x23720fc1f7c2ca6ffc6da9e0068b822537a340ec",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x02dbcc28a565967b56caf712fe8c043820b80998",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6fc03b0fef02c8d39faae2acf62982fccf77c6d9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x727c8cf6ab0520b28cf5b6497efff1cd7d9c87a9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf7c9ebed1a2f73d6873b01b5710dd1ff3ff498ed",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc2fce45ae2e5adb7d2544a879253261ed7a2fdb7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xad80177437a900f114954ea6e122276505f687ba",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x95c26c6a2bd38d1781719440ee075ec0604de5a4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x95c3ad390ee9f6efd2bdf6121ab7391d5d4b581d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xae17776b73c972faa3df20c644f4af3152852ba3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb4aff03d2c87208ea601e5dd594d14b8084dc70b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7a4268fbad9d4f743e21a840d6b32ade03474df9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x82466446ac52473945cadab9c8721b13e28469f8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbe27d69c3b35d95509748fd37f23dec7facedb72",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcdbb8b851734665726dc8a39d4e85718731d1a68",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0e8c699938b0c30ff927a24b32ec2d3b24da3e5e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa130dfbe044365931123ff47798b2dc88c0d1f6e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x19775082c380899123cadc0b8fc7dbb4a1916b30",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf608fc5c056a8aa1bc41dd19c4c3df3dfc5fbbae",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x58d4644cccbe877fa9d05fe5813f2a597944ca6b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5f38474906633b5f206652fd9a351d05d757b158",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf6ac986cbb50f3ae9b3963ce0e22887fb62d0ffd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x799d8b09168899febbb942acf4e903406ae32562",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe4f24dc72254ef707b30a1ca4b3a5f33998222e9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4f0445a1a4f6aa3bac0f4f1ba1919366aaaf730a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa5fc3b85bf124276e8a615a0be418256051a58ea",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbd996b850251e584695a3e29be1980754d0115d5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc353a1980eee2c03da4bc22464b55c7ca4c0b7cb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbd8f9d071572e2b7f3915a4848829de642729207",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf019279262ebf2d9c32099d7b92669ce16ebd497",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf232f6c0b98ab2dd8f017fa64d36bc3091b5589d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x51d8ea1cad45b282f3791cd19fdc6af6a81837f1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x58e6d9e0f2295950e02f7f6a1c47419fb4d1a230",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x27e4a3e1af4952d2cfa41ea0e3954d17b7a3d83b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8a492f420a52ac7371cd5259d818059988bbcd3d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe3caf1164af15d8ecaf5a55baa80e23cad07355f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4b13f587c528d709f8f56809c8d44aff8ceb84b4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xaff681c41b2a34917fd86bfbf877d777486408cc",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7c7235c54d67761af6e257951ff7d71232716133",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x819285c57b3abdef4903f2be3af7de8fd195a76c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9bbf0406a4c9d74cc50056bbdf145b0fe57cafec",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9f7063185613cc57a56077bb52455ee0e5a57b72",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x94ac08089e2cc4620a0bc81d54a8e1c1a3332e97",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3b16e043462ae353f0f31e5263b56c6cbfc389a6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf0d2b28c615c7cfb3a0743f1686295cb5921cc57",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7d858a937b9e0b4f43643c5222ad31278e15644e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5f7e2303cd3da27576d6894c8dc7a5af7f4e1aa6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3e59cd8fecdc178125a2f31549958efb5a6d536f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xeb2ebf886f1f9fd13f7b97ecf7cb1a12ad862518",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x830ad356ae9f4032df9fb0a0a276e894d684f85e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf3bbd26944777b14721ab1fadc60ce24a03bb678",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x81c5a0fdd5bfa461a9ec882aaddd213742be053e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbef084ce2026cac9de74df43852eff0f9a5b3dc8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x30ab8de7ea80013678822557e4cfd41e6b3ff09d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x168aa5432092ade993713d283cfabcc45dc325c2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe806e88eeeb0044ac2901fa579e6c71ebb1bb737",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xab3634bb371f8479189627f69d22b4e9e603b579",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0a2cd44229a6c8d8d55177c5494e16bb0e40b6a7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1a2078479dfad04fdd38d03dc4213f392effc883",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa89b2034e974d18eecb4d391d865bb0e577ab74f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9bde30bcf8fa17eac99ce2f8d796134df586822d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x48fee644e6615971d9d6b366d418e746ddd65b2b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x08e0f38c27fecd115af1fbf53181fa2bda6c41f6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf5f56471917da966480a796885a0ee6a976a7251",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd820fba7994809621e2b2856341746744744ab64",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc70ff1472febdeec62ff2d1cc0863a971612ba90",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8db165baac591d7ad3b020fcfaa06d751e8f5c04",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x73f4ce9d004c28fdf9796bf9043fabf849389545",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb322d3423266c4494854cfed97c87ba8b58539c9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xabbe86522013fd9fcbbb531977a46114e9b8134b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x39235aa9bc1a96a4f7d12dd04fed6b488bff0a91",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfacb283156d54e9b07a186305a775d10def8aaa0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3fd6f9d339dd8e38a9cbe559c9dcd281ecfdd1ef",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb4f9263b42ea01c9c2e2c4822bbb9f010ba1f230",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf771a8228b6ef1d3a8bfe09e5397c8b0081aff51",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa1d0acecd29c663a123a6f3f8a9ad87413383fcd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6d14791d7bda2198b65b53a1f6711191c7e980e6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe175c9c9b30ff0730346cd291018d1003bf999d2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9bbbd3b79e276323e250ff5506744555d62b89d9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xafd1f7dfd49b95380f723024f649109b55da7f46",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0065843c6d8645f48e902234ebb60ac3b87d8b45",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa93cf7a8da87cb75165a199ffcac1b11cb8b21b8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd9f5039b80eb6e74220c76832fdc169485929290",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x160a5099face0c5b65c094a4935767c79169fd59",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8fba660d9292fcf6a80e3a7d5ffb4364a5277e46",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3da25317f6f4bfcf5834f2ed2ef25e3498a4047c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x38169920ef388907a51be3edaf8718ec79ac4da9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x49ac033b3dde7bc4e0a3a92cebf0aed7e2a41af9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8e6372a9c21d5cb0de94b228086bf780aaa31845",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3f8bcde79bb637232dac25607a85a8ec8a88bc34",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4de338c87a88270dc51437065c35fbb127a2ffd5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdd6ed6eb3d2f7c893ec1f0fd84a3f67c3a931022",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd03aa768d52a2314dc479ab8978a1c0f1f37de2d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2a5478fdd759903f606c383306e3cba5af189084",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9958bb24987832fba2cb00eea4b01d69943c12aa",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xaafc40e052a76ebbb411ba5ecce344c72d2a1623",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6854a0a2e848962ccb8d73238938c0bfab894d4b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe8cee250af20d35d64ffcfe825c77f114ff5c931",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x19d5602ec91574ae892f1b5d7ca2e483438c855b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2fffda563288d7510d7436c2aef61569f6c443ec",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x924cd45897ce81c5f39ebf7851af12cd51e57706",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa8668c046932d4a4609527f55ac6a74b3559ffbc",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf27ad50bbf928e743e5562abf3f5756db0ae352d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x34ee4a1289816507f3bc6ea0c9ecf881afe54ad5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2d7ce7f3019ddae670d48aaa1de6f5b8df26b3fc",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2c91dc83b710727bc16479e7e345454b0d750c5e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb8102316ca2f36eb3faa0a846fed9e1641f00a01",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xccf640f9dfc13b36bcfa12ab934c2197a7d76057",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf7d5f7fc4dcf15e751df3f927393afb11f72390d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb89ef2ceb4ca0e8d521667588be749b0598d0251",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcdc3a58d156a28121beff85aace88d8d7d3cdbad",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd63deecadfc47133ed9872187fa2ce794c6a13df",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x11c93bee6b21bcdeb25c74e8906dd4fe1f6a6a85",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1ba2f88ad94cfdc927e3c658b5234f5eb4fcf7df",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2af5579b13773fe9a175771d281b6eb3f63eeefa",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x21ab656379d52b29725e8d284f8f48621306415b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6fc718766d10cfa44abe1e370edc50bd48f2179e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe975ef38b7243c7d684f39f1eb6b20205ac34865",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x73396d8405e30046d75a6905f9b0a22915b7120b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6f21aa9b72af0505f486ffd4c75347c5cf47728a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xff8c28fb373002e07b2a4b4f27f20df70d0f25c0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa454efa006ff0e5a3ec9b17279641a0fbb1134d7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7d7f1a559d3c2c21c02c201ad6c4518e24228b82",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7481f25a6098b5e2d91484987e31e3b2ebe9ccea",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe591c53cf86a26f2144199e713da29c152358513",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc0fad26b040e8a30b393f56327fab79ab1c3e8b9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3912378440157f8b3800b2b692e1dc9e75fb776a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x956540ff6022ce3d9143b0b5abacc2da593d1144",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x09bb3ed0f506e25b8fbfe0222cce50a32a9ffa3c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x57899323d6d05a9229ef4a7c567a824ae1e44fa9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4f2b5238c112834de2e7217cce19c8d139001e84",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa2cdb4c9f60acfa2ba5cb58834ac96a925a349c8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0d2cd563b8416801b9c0b5805cec9f8aaac256ff",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x682c236fbe4ef6b057fae5245358396a0042ecef",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5ebb2fe12e4bd114b731a74a2be1904d9a2975cd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5b87595f3bf84cf655a7640ad9221af58af805c7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5754807f9c300002c80b875b9fd9f02744f6b461",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x38825f2150be9b8bbed5edcb6f2a3738fbf56274",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfccbaa6ac22bfd4d133dd13079712b178878f7c1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf70b10c261dc364cc0257b2f2b3e66faad09f4bb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x14eb9f7744fc70c9eddd49b51eecbb04ef1ab049",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1e0f365d580336486035cbe3fd4b91eb68fee3f1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x13505405a23c41fdab4e7810dd37bc4b751f6a6b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdf2db058268f7ca557c8563ee1968cce55495588",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe319aff922fe7d15b72dccc7e1def1b2f5825ca1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3a294540d36cb663969db6ebda9fccc05d418301",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5e13c15c9d5623682e5ceabb3d6d69f7c9cc33e9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x372a02df70045ab03863cfc0fdbf90aee637b49d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd1c6ec0e8da70ef7bff743ecb8fdb5fa7c47abb6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x204b095bc7b27bcf6be25f17cccaebe57bdf5697",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0671ad1d27cf1666e7195f7dd8ed520c9a15ded4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbe46b7b4386963b3a4d61550716ce93f4a5c9b58",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2a27baec2b56e9949e466d1658df09087569ee04",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfe8fd9fc5d97a8970d5d986363f4ab589226db10",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5ca4a395f07400537f4812ce33c025f605d58c42",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8af7222d15850b0d9ff2056b8bcaf07f07d67112",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x41c63255388a6a38596f4a12aaea2a89891bd129",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4388073e4a03d9a3a5cf738923136d9c9b7ea656",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcfc0fda8261838a55711e9255cde8fa7c6546a9f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x38fb4a4360c131fb03d3bd98dc8679bf0938a072",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xba05995cab5f2840f224f25a9a44350071937fe8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd7646db8c2a76fc88dd753f62c480d59c10cc8c9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2063aa7f6defcfb16dd5b2554adb909005627156",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x624bb65d16fa9464d5ccab0908a2d1a9a513492c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf654fa42177e9c0337a317a6f8c9beb282d9cc8c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x826564d1c7addedf521c1e7165b5e19f8fff9187",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x92280680154767f5bbf6d9202985031b1181f2a3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x79aed63e3ca08aa49b71cff164ce5e0682e165dd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1ee9529a3bfad1d4d9575cd8a5b889adb9142143",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbc13805fc12c8cc93a91e7dfd45635823f44b9e6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5bbbc63f1021b2ec77d1250dd532fdb44b66bd84",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7ed21a26e95cc3f3c80ae3bd503c3f9d4eb92698",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1ab664bca467a33c74f01d0d524ec592205b041d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x857508a084cbf65a5d5a97e313284eeeb25bc2ca",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbb0ec54bf353aeb3302f39197dbc23ea9ea87cec",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd7925379b4878bc77d5ed90aba72833fc9e4adba",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd755960aabfb252657e41513a9a54b3dc4782c22",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x345237b564dd6a51a31cd2e8a9d6eb721459edca",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3296a6dc2ccb1ce49350f07efa237af995a4ac1f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x12c2907b7205e9548afe74a0e266595db0fe8367",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2b39099b2473b9832dde23a766c6b7dc4bb6c39e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x18eb17833a6175d042cca1b759068ac668198d5b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xff7bc24be634036854fdacf81c660b54adef580f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x69500a388924c75f2e626bfb4537d5e020cd8c08",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x60ec0c8d809d7e15e71354e478c5356439aeb7e0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x49076bddbe8c1181aa76096cec62b0faff2d808e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x509baa1490c8a4dcf94612cc7f870c02a2e48a25",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x582342b2718d2916680f7e22d47d370a5b86aff9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x44757f3cb8d4a23459ef939c51a2fbd914745fa2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x896e67b65c340ceaaf5386520204ed33d4035c12",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x870b5c77c93c82d1e0dd2061dc1ebaf990fa6350",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x22ac4ef6379cd6083344fdf52288b00f6e85fa3a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x705b0bfc3ce5e4b3c5e2cc8df8d1ef857dba3892",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe22dbcc26fdf0265f689a46763cdf8bc3f9c30b8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe2f2776850e5cb8bfb1199b3f902b742de57272c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8af0f927345414829f92e0d6dbcc0ff4b3b0d426",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb56b46bc4339133e7eceb3c891094bb593a3ba2b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3e40b3185ef8a032e35bffb578358a3b3b672f6b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x460d46f5ad9f23b83c352c8dd50fbd437ddbb695",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xedc6257d62b3ecef87fc789364c80ed0eb3ea6d3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdd5297ac82982361b72baca469c48dc7d236caff",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5f5f9b38b860bd91b3771a12c202eece2d868c60",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x152608a77c53ceeda47eef2a1c9b3753777a315c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7a9c920758690c441bc7427feb2d92564b95e161",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe9383625e1acf886a4c7c16e70dcd79709ebdb0f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x32160e3bad2004d0db3ce5737fa468d9828b8df9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2407cf02a41eeee86744988cc2ac6717acf3dbfe",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4058ffe92e0b873130cc4fd3b2a9dec1cfee424e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8dd957aac8e54437e17aa70b5a4946520098e977",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x17583f6c78865cb11c532ddb7e2945402db03c7d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x119ef4e8d30908e067fccd4bffeb1d398e4bdcc2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x582bb23d6acb32c041d19d2e79a3fe3892a9f244",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x214eab8460d2cde2905743b55eef30e9bbe70d52",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x06519a940d08f0ac4e48ef864be74bb3a594f317",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x791bcf451400c6c27edba0b0360988e27485159e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x90a2345c40a72e6cf1283399bc3744d37ac2ff4d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x13cab8cf31e9f6543ee51626ed0c84a2218c7561",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0d90c3f4c3dd5ff25b783dba7fa213ce3c7f5286",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa559b0bf8b5ecff7fff4a870afe10476ae2070ed",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcb3964e40db86358380512a080e20713bff79fbb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x13c43eb4b3708fae25e8e259be56eb10449b05c2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x66d82f07e4a86c70b0cd7d2f3fdf1f2a9ab7408b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdef3304de5a4a79d2a7ac5f2caec7d205b284292",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe1dffdc87eed3d296c70e96f6aae105cdae8296b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe4cb39973c5513f62538a8e69ff7d33abbb6307a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xbf0c4f8af98e954cf26aeb9f7e4978d389d8ab14",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc6b4feadfc1624ce4eb4c1d3d236814954e07db9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1e2c510a54b6aec4b86fedb1bc131f8269afbb42",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3ceafbdf84bbf35a0ede92146c54eb1354f246de",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x18865b97d2f2107c96648f06d9c2fe47c92b62c9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2a84f8ebb10a9f112965e03c8ae1284970646d45",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x87a11df5053b47186c8aa1167b060fb73d7ece1e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc5741951a5ee6f8c6960b79755a8a05e6ca1dee5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0cf801cd9e3980f61f8881a810313ad43faabaa5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4b3d7a4b47eefc344bcb49d26cb1587ab29db83f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1a1fe3d082647b37a45a87d3ed99bafc175ee6d3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3b8170c17b814172ac1c50d1dffdee4246308d20",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x06ac0789fb1c0f899f35ee529e0721f492d7cb61",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x14d496888a955ea091671ed0de08a664e02fb76a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfc941bce640254544f34d2917c9ccd22a6c2acba",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa33a1cf997f9d2ccb599ef6ff5739b05d2c06dc0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8f81edcc8b2c0e329c28c6ba94637219b44dada1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf1ce39ef582fcf41dca31aff61f93952498f46b0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x97f3bd3f81363f9f1a6036a68aac8684c4e27dc0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe26e5fa84dd97d95afe07193ba47919eedc47978",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xea0620364c66fd0cbeb30502865d163471ae116a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3bef3a24cbc93530800f5441ecd89769944f5225",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x235b3739aaf3f816f186ed139056665ac79e8164",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8f2394738e881a52d5a9277311c052120382fb5e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8879ec394d83a36a3990b8b9b450a94c5f011142",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x196bf94b01df24a1d3e638afb62d7979d7ded982",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x88f6322727e7c600342f191c50f2528f97f6d4ce",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9bed49f189c8314d9d20cfd411b909e62e18a4d1",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3ff8a20c0a9a57057080073d6fef9983fc76a659",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdefd935ccd3a238b3c5b0e7ca021f357ec722a04",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x31e7488c3fc5dcc878649d65be05cebaa576121e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6f2a32032569f79779ab2b5906b7194ca963d027",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0b2639b605fef9d1aec54e8cda661c0c7819cdc9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc85f785da92dff2beaa21083598a6f5ed005c0a7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2c0486fae683d559aa332f1acfe8461f20394228",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x648a0c109684110430ba89e57e99af656954af55",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x397cd7eee3c35460a1b834a33048ca1df59e72df",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2aafcb11f16db39df87f0a697a6c4dc0c721fae0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf6fe75730543ea2e4b297f01a47c3754a7e06c81",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1a3916098e2d1426055ac4b31cd25cfae84ce0bb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9dfba5af627b94980e3ea0fff5e6226a0f6d3d38",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x387db530666ae28919496cda0ee074322267beba",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc9abba0acbd62472a40e067587c16c248df26a78",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0cca5790650d90cb8f11a31493329f6924ee7f4f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5bfc77969f16cfb6fcf2ebb8c7a19c0c5f4c2972",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb2ec2522b4f1e928ff026bc3b249f2a8644f68ec",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0722e3c50be6544a1d313216af7344b7383e0f9e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5a2adbd444e53ba007b2876a6a17265c0529e208",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4e345f726480750f41f78319363ef669077327b9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc85ca4f65467e0ef1f41ef41a721e25f002f4a00",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x410bd77cb34ed08c2b433958bf81c10e2cba3ece",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x996a34b33cfdb08d7038e2abc0b7fdff8084a27f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x26fd5eefc789fb79cfc1d84b86d681f6aa9a7f08",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb6ad18cbb41a8e3b2d4da27fffa973b64c9e3755",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb23a15a54a1f70de2ecbeccdb25479ee5d25089c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1ecd6d28b865c379383a72f71a3fb1cac4b5af7e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3fd208de93d47d47881f0ad96e8d8c514806659d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0bd1124bdd80dd07eb17233b504d0ec0c928a8d2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb73c82ecbc20a92784ae6d4a652c276c52b2c114",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd2a8c6fb7958e436527dfdbc2c2d46dd52b6a287",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x81bdfbb1f2a63e7c9fd5f05a988303033f46181d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3a10885a0c3bf9bc10ca744fe3cf6d3ad4c20182",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0666b4940575a50c386bf7f3e3a59ffc069c4988",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfba128aa4cbcbe153ddea6605c1ded705857a731",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2254fde596e665c45771c1bbadf0f7aa8cf0da49",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xac8508fb068afc1b0fa636e9525ac9638ed62d02",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x03402ebbf55e15a5a24e44e142f57a313c0a3af4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1cec484f01159e783e474d872b3b8220d3251a36",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5e31189205c2c882f3815bbd3230b936be2ccef2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x42d52ab953a67758ce9979793016bbb7996600f5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x11dc704f17423cf160a6819e236623aeb63b10bc",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1d330cb60956be43632fa500d46521677e01925a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd45695b81f2c7cffeff300df918d8ba70e9c3dfa",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1e34b86977223c8f796667e2631aaa8d26e2b22a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x797d1e8361db821115237f3ae905d4a8bc2f70d3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1029313a234711535f271285bf9a6e413b7f1293",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe721279ca9e4c0cf7ca020b0b627ae0653c952b9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6ce720d701d2bf0dbc8582167c575a37befd749d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf4031d85de3f50e1ca23620168a962101c413f65",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5f150fedda212025ae37ed36877ce56284f27853",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x350ef5736054d059073df4e6ba429c57946fb7d7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9f92fdf57b13abca2dd21221715c983390a55bb4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb02228ea19cf852b79c277f3379d917c766518df",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x15b6486f67538d8fead0f0ba587f89d63c6eede7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x46cbd44608119727696570aeea85441c930408a9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf22c727bc91081547f732c4d82e291aa56d5d197",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3eedfe03571664db5e1ce4e91feefb64362797fd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe30d9314154481c2a9d59bb6d2e097eee62169bc",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x605164bf8f0cc52d458e971fdbd5a8cf69869acb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5bce7a0ea9fabadb4d2ae4ae52f716dcff1efc52",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x930def0cac23b4fe85eb416c5d398d2fe5a95497",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1f64d87ef2bc065bf77f5b699ff6f53a2d50b4b0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9a109b369ccd44d367b2e4da227810a0b02cff96",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x43f5a061ccb4732a89f9d92621b750a020b8b53d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x17c6a4d7fd9d189d67d89f33785bcdcf37050bec",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x18f9c4feca8652479dd4d0585dd73a5b0c9750ac",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xef3b9f938541d77a558d8f6c900865d7877400b2",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf2afdfb9c8be0392cd238dc56bdce649dcf8c160",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6566a8520cc26577839e60d18e3b0649c2f7ab0f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5a51a505a9e4607638ad6625560d2d837184ac9f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4661f6b8d44136310b193546e7ee28e33af32a5e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x74444a7d4d72f9e6aee2b80ed0bf0f9032864a70",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x79a5e4b12ca947aed260007bc4ba7608fe08cd9c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4b58a22bf09c2f13db3123ffed2baceb5d92d144",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xece1ee27385a38b8023847ff553a06158d89a707",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x793d8a671ff0b71bcd143af7251f27cf489387c8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4c22e15c6f88501eb2ae979c05519d5e91004e71",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe714f19d0cf0b57fbd68dcb8ed7353d15ccd1b00",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb34352da728a6f9a765f3862d6241e34f0a99fc4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3d68ba756ed59a9bc7a2e420bb38084a981bdfeb",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc6108beb5d509cf73615ab94ee5b5f5792cea63a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd3e50e87be433a5dd9a9852ca706340b0d1a9d53",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xcb7052ff20d3003a5749d2cab36213be1c189da4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd16518419a1c3baf069f625203b66741083467d4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa9bb6e134263859f8a54d07330009d0f86cb7588",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb4504c54298db51feafa826faf5f60cc0af00ced",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x75deaead62a949587cb52b3f36a3c86fb7ce1e57",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6e9fab2e0a59150685ab00f5b40ef2cc14d186d8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb412dc1866a1d38d3b4ad912ef19544dcc1bb6d8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc9aa7274d9de874fb62a189eadedda5cd680661d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf19d12f56102b95deeb00b5977b9e1333c7bceef",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7418d951e08953ec7c8ab276c3256f0c06fad492",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x22e83309a9f3dbc5b849d1a59dfa3ffcd08abdc7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x09ae5a2281d755348d728be636a4c2a7e5fa9978",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xec6d0eff61fe5596cfc36392b53bb9d7be46da2f",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x984ad0877572f0786ec64874e1968eab714a76f7",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x78b2223a1892f32aff181d5a421de5dc27e25a0c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfb742988d11a620550812e7ddc671d86309fe63e",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe96a5a2c57bcfeb0e0289f7896ad44bf0e982259",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x62d7ead38d19e6a2dc26891426f286a2e10f83fa",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x34030d5269419b467d1cec31bdcf205cbce9a87a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8e25a0f52da8be776094bba2bbc6f00a19cd97ef",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x59c53c70b2707a6076df79a67aa7921096296cbf",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6e66d0f3b9a566198d9f44555f7c933a21012058",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf0955e5612dd0904cd40834a16908500dc4346b9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd58e7b40c429e8ee14c82b7f303bdf23e418d90d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x34fb04152817f4bb0e93047be2be0435b9794655",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xdaf3cb3965fb21644a8a0b114b87cf8f531f4ef0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x3b4ce416647796a7865b0859e226073c39d6e21b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x279f85dbdad86bcaf4276d7544b3933dd7282739",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf105e8c930aed22b7c5cefe4300211f4c0858543",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1d881fc774010a07ed54653449473bfc463bb520",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xce079ebbefb46cb662a89b01dd555cfb0daf7bdd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xfea520a070235e2845bbe5b8355a8c0113a422d4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x80faaed6065f22fe187d84750b03230e413f3f0c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x932dc709993ca94f3bedc048df9a2939ae72c809",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x993fbb87ad28e5c12ff95ddd9416c60a0b474b06",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4df5a4ba48511a863c2daa9d65b579456d27a170",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x18907941ae0aa41dcc6b17a31e14fef52d1cfe24",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x699c6d0a404807855897ca21e56eb1745162fa38",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x177676a1d5299602ea8923bd45251b3d5f30f694",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x8d0450315db1916e67f8017268b4c396dd28ef88",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4a2e02c18951c3e9ea467130b1c2a431a24675a4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x9c21a841358c8f28b52fe172ca93cfe8689fd929",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x131e58d502c92959066c6d476f531f6dd4784db6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x45b632d1b9cb1095368d670717f5df3a91ffe4f3",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x17feb75f1c3dcc0efcbb6e28a9522cb6ae3abe81",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x7512661849d7973681135f5206bb1d988a6c9166",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x795ba6ce97bf22b4df8e8000858ace606f638bfd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1e708e37753a752fb0bdd9afbe41ba40b8bf05a4",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf43710e89c3f392757c5a708387cff6ee6bc79b8",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x2b28e4cbb59622542e71f261b186da5710f82a7b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5792a0bafe3385ac08a16b31082cc4337cec7dc6",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xa968cfd15acc30ef1c837bd6b5a8472a4a90535b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6a786337b2a9d53de36c4ee703022c17abc77aed",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x65f8a419309cff3bb7cdedd54a87cacff30a433a",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x0575cb088d14e47ebf4a9f7a34bb8386086a3e61",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x6b97fa4de8f0556317f2b9f41222f7531cfa1855",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd5cb3645acb8fa10bf07089abf64569a6fe7d484",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x770687deff65f06e1bfaab63517d1594ca42a431",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x43fa9e3011ff7d75a80ffb9b1a60a41746fb931d",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xb1ac35c9e15211e960c7228e22057ff597c37b8b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x281624f0d4eb4ca126b5294483922d90391f6a50",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x40f2c642e03369d9283bb35959ac4222649e86a0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5caa476c313eaf24ab295aa44e44d351c3e717f5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x95dd249db92e84fc608ce4ea27fca89e1dd18907",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xe3fc65f147a602892c096fe5e363deedb650cd7c",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc507dc34a5cf1cbab22c242f003b2a0e5d06e382",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc8f3ffcb2bb0620c136e295afed1654029db4773",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x1e9426c4207b06768714b157d34593e66aeeb3c5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x35c8d1ef298dbf5398829f649ad0c52703d66030",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x69c0e934c929d37eb21d90a779fa5322d56b3f29",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xd56d3f9206197eb2f72b36b2cbd4c925d99092fd",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xc4a0ae709ea9cf9bbc892744c9019cb9e6a3f2be",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x08a9ad02e71ddc4b294e3784d6b2b5f95486f7d9",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xec190478f494ea74c8574828bf033dced8698203",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x5f63a8ee41a52a8dbc212854b4015b8dd844b7a0",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x4d359833f4034b13ac1745610f63f92764cf8310",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0x063552981f0cd25bfe91ced4fa876a10cf12319b",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  },
  {
    "address": "0xf3bd43613408e2500cc977c815adbfe6918ea0b5",
    "result": [
      {
        "SourceCode": "",
        "ABI": "Contract source code not verified",
        "ContractName": "",
        "CompilerVersion": "",
        "OptimizationUsed": "",
        "Runs": "",
        "ConstructorArguments": "",
        "Library": "",
        "SwarmSource": ""
      }
    ]
  }
]